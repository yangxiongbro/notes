# Java



## Jvm

## 内存结构

### 程序计数器（PC Register）

#### 定义

Program Counter Register 程序计数器（寄存器）

#### 特点

- 线程私有
- 不会内存溢出

#### 作用

记住下一条jvm指令的执行地址



### 虚拟机栈（JVM Stacks）

#### 定义

Java Virtual Machine Stacks （Java 虚拟机栈）

- 每个线程运行时所需的内存，称为虚拟机栈
- 每个栈由多个栈帧（Frame）组成，对应每次方法调用时所占用的内存
- 每个线程只能有一个活动的栈帧，对应当前正在执行的那个方法

栈帧：每个方法运行时需要的内存（参数、局部变量、返回地址）



#### 特点

- 线程私有

#### 相关 JVM 参数

-Xss size

Linux/x64(64-bit): 1024 KB

macOS(64-bit): 1024 KB

Oracle Solaris/x64(64-bit): 1024 KB

Windows: 根据虚拟内存决定



#### 栈内存溢出

##### 栈帧过多导致栈内存溢出

递归没有正确设置递归出口、类循环引用时进行序列化

##### 栈帧过大



#### 线程运行诊断

##### CPU占用过多

```sh
nohup java -jar test.jar > runoob.log 2>&1 &
# 2>&1 解释：

# 将标准错误 2 重定向到标准输出 &1 ，标准输出 &1 再被重定向输入到 runoob.log 文件中。

# 0 – stdin (standard input，标准输入)
# 1 – stdout (standard output，标准输出)
# 2 – stderr (standard error，标准错误输出)
top
# 获取PID
ps H -eo pid, tid, %cpu | grep PID
# 通过PID获取线程
jstack tid
# 通过 java 工具获取线程信息
# 将tid转16进制，通过匹配 jstack 输出的 nid 定位到对应线程，查看对应占用cpu过多的源码
```



##### 程序长时间无响应

**死锁**

通过 jstack 获取死锁信息



#### 问题辨析

垃圾回收是否涉及栈内存？

不涉及，方法调用结束栈帧出栈后自动释放栈帧内存。

栈内存分配越大越好吗？

不一定，栈内存和线程数成反比，栈内存越大线程数越少。

方法内的局部变量是否线程安全？

如果方法内局部变量没有逃离方法的作用范围，则是线程安全的。

如果局部变量引用了对象，并逃离方法的作用范围，则需要考虑线程安全问题。如果返回的是基本数据类型则没有线程安全问题。



### 本地方法栈（Native Method Stacks）

#### 定义

本地方法运行需要的内存

#### 特点

- 线程私有

### 堆（Heap）

#### 定义

通过 new 关键字创建对象都会使用堆内存

#### 特点

- 它是线程共享的，堆中对象都需要考虑线程安全问题
- 有垃圾回收机制

#### 堆内存溢出

java.lang.OutOfMemoryError:  GC overhead limit exceeded

垃圾回收器花费超过 98% 的时间只回收了不到 %2 的堆空间时将报这个错。使用JVM参数 -XX:-UseGCOverheadLimit 关闭该错误。

java.lang.OutOfMemoryError: Java heap space

堆空间内存不足错误。





#### 相关 JVM 参数

-Xmx size 设置最大堆大小

-Xmx8m

-Xms size 设置初始堆大小

-Xms8m



#### 堆内存诊断

##### jps

查看当前系统中有哪些 java 进程。



##### jmap

查看堆内存占用情况，只能查询某个时刻的堆内存信息。

```sh
jps
# 查看 java 进程
jmap -heap pid
# 查看堆内存信息
```



##### jconsole

图形界面，多功能的监测工具，可以连续监测。

```sh
jconsole
# 连接到启动的应用
```



##### jvisualvm

堆 Dump 保存快照，查找分析占用内存过多的对象。

```sh
jvisualvm
# 连接到启动的应用
```



### 方法区（Method Area）

#### 定义

通过 new 关键字创建对象都会使用堆内存

存放类结构相关信息，例如运行时常量池，成员变量，方法数据，方法和构造函数的代码，特殊方法（类构造器）。

方法区在JVM启动时被创建，逻辑上是堆的一部分

HotSpot 在 java 1.8之前的永久代和 1.8 之后的元空间都是方法区的一种实现。

内存不足时抛出内存不足异常。

#### 组成

HotSpot 方法区实现:

![](D:/documents/notes/pictures/20230315/006.PNG)



#### 方法区内存溢出

##### 例子

1.8 之前

-XX:MaxPermSize=8m

1.8 之后

-XX:MaxMetaspaceSize=8m

```java
public class Demo extends ClassLoader{ // 可以用来加载类的二进制字节码
    public static void main(String[] args){
        int j = 0;
        try{
            Demo demo = new Demo();
            for(int i = 0; i < 20000; i++, j++){
                // ClassWriter 作用是生成类的二进制字节码
                ClassWriter cw = new ClassWriter(0);
                // 版本号，类修饰符，类名，包名，父类，接口
                cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, "Class"+i,null,"lava/lang/Object", null);
                // 类的二进制字节码
                byte[] code = cw.toByteArray();
                // 执行类加载
                test.defineClass("Class"+i, code,0,code.length);
            }
        } finally{
            System.out.println(j);
        }
    }
}

// java.lang.OutOfMemoryError: PermGen space
// java.lang.OutOfMemoryError: Metaspace
```



##### 出现场景

- spring
- mybatis

使用 CGLib 生成代理类，mybatis 接口实现类等



#### 相关 JVM 参数

设置方法区大小

1.8 之前

-XX:MaxPermSize=size

-XX:MaxPermSize=8m

1.8 之后

-XX:MaxMetaspaceSize=size

-XX:MaxMetaspaceSize=8m



#### 运行时常量池

- 常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息
- 运行时常量池，常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会被放入运行时常量池，并把里面的符号地址变为真实地址。

```java
// 二进制字节码（类基本信息，常量池，类方法定义，包含了虚拟机指令）
public class JavaApp {
    public static void main(String [] args){
        System.out.println("hello world");
    }
}

// 反编译二进制字节码
// PS D:\develop\code\java\jvm\out\production\jvm> javap -v .\JavaApp.class
// Classfile /D:/develop/code/java/jvm/out/production/jvm/JavaApp.class
//   Last modified 2022年6月27日; size 524 bytes
//   MD5 checksum 7c885a2b9385027997581b72fac41fd9
//   Compiled from "JavaApp.java"
//类基本信息
// public class JavaApp
//   minor version: 0
//   major version: 55
//   flags: (0x0021) ACC_PUBLIC, ACC_SUPER
//   this_class: #5                          // JavaApp
//   super_class: #6                         // java/lang/Object
//   interfaces: 0, fields: 0, methods: 2, attributes: 1
//常量池
// Constant pool:
//    #1 = Methodref          #6.#20         // java/lang/Object."<init>":()V
//    #2 = Fieldref           #21.#22        // java/lang/System.out:Ljava/io/PrintStream;
//    #3 = String             #23            // hello world
//    #4 = Methodref          #24.#25        // java/io/PrintStream.println:(Ljava/lang/String;)V
//    #5 = Class              #26            // JavaApp
//    #6 = Class              #27            // java/lang/Object
//    #7 = Utf8               <init>
//    #8 = Utf8               ()V
//    #9 = Utf8               Code
//   #10 = Utf8               LineNumberTable
//   #11 = Utf8               LocalVariableTable
//   #12 = Utf8               this
//   #13 = Utf8               LJavaApp;
//   #14 = Utf8               main
//   #15 = Utf8               ([Ljava/lang/String;)V
//   #16 = Utf8               args
//   #17 = Utf8               [Ljava/lang/String;
//   #18 = Utf8               SourceFile
//   #19 = Utf8               JavaApp.java
//   #20 = NameAndType        #7:#8          // "<init>":()V
//   #21 = Class              #28            // java/lang/System
//   #22 = NameAndType        #29:#30        // out:Ljava/io/PrintStream;
//   #23 = Utf8               hello world
//   #24 = Class              #31            // java/io/PrintStream
//   #25 = NameAndType        #32:#33        // println:(Ljava/lang/String;)V
//   #26 = Utf8               JavaApp
//   #27 = Utf8               java/lang/Object
//   #28 = Utf8               java/lang/System
//   #29 = Utf8               out
//   #30 = Utf8               Ljava/io/PrintStream;
//   #31 = Utf8               java/io/PrintStream
//   #32 = Utf8               println
//   #33 = Utf8               (Ljava/lang/String;)V
//类方法定义
// {
//   public JavaApp();
//     descriptor: ()V
//     flags: (0x0001) ACC_PUBLIC
//     Code:
//       stack=1, locals=1, args_size=1
//虚拟机指令
//          0: aload_0
//          1: invokespecial #1                  // Method java/lang/Object."<init>":()V
//          4: return
//       LineNumberTable:
//         line 1: 0
//       LocalVariableTable:
//         Start  Length  Slot  Name   Signature
//             0       5     0  this   LJavaApp;
// 
//   public static void main(java.lang.String[]);
//     descriptor: ([Ljava/lang/String;)V
//     flags: (0x0009) ACC_PUBLIC, ACC_STATIC
//     Code:
//       stack=2, locals=1, args_size=1
//虚拟机指令
//          0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
//          3: ldc           #3                  // String hello world
//          5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
//          8: return
//       LineNumberTable:
//         line 3: 0
//         line 4: 8
//       LocalVariableTable:
//         Start  Length  Slot  Name   Signature
//             0       9     0  args   [Ljava/lang/String;
// }
// SourceFile: "JavaApp.java"



```



#### StringTable

```java
public class JavaApp {
    public static void main(String [] args){
        String s1 = "a";
        String s2 = "b";
        String s3 = "a" + "b";
        String s4 = s1 + s2;
        String s5 = "ab";
        String s6 = s4.intern();
        System.out.println(s3 == s4); // false
        System.out.println(s3 == s5); // true
        System.out.println(s3 == s6); // true

        String x2 = new String("c") + new String("d");
        String x1 = "cd";
        x2.intern();
        System.out.println(x1 == x2); // false
    }
}
```

常量池中的字符串仅是符号，第一次用到时才会把字符串从常量池中放入 StringTable 并变为对象。

StringTable 是一个哈希表，可以避免重复创建字符串对象。

字符串变量拼接的原理是 StringBuilder(1.8) ，从反编译知道。

字符串常量拼接的原理是编译器优化。

可以使用 intern 方法，将 StringTable 中还没有的字符串对象放入 StringTable 中。

##### intern()

1.8 将字符串对象尝试放入 StringTable 中，如果有则不放入，如果没有则放入 StringTable，然后返回 StringTable 中的对象。



1.6 将字符串对象尝试放入 StringTable 中，如果有则不放入，如果没有则将此对象复制一份，再放入 StringTable，然后返回 StringTable 中的对象。

```java
public class JavaApp {
    public static void main(String [] args){
        String x2 = new String("c") + new String("d");
        String x1 = "cd";
        String x3 = x2.intern();
        //1.6 1.8
        System.out.println(x1 == x2); // false
        System.out.println(x1 == x3); // true
    }
}

public class JavaApp {
    public static void main(String [] args){
        String x2 = new String("c") + new String("d");
        String x3 = x2.intern();
        String x1 = "cd";
        // 1.6
        System.out.println(x1 == x2); // false
        System.out.println(x1 == x3); // true
        // 1.8
        System.out.println(x1 == x2); // true
        System.out.println(x1 == x3); // true
    }
}
```



#### StringTable 位置

从 1.7 开始， StringTable 从永久代中移动到堆中，由于永久代的垃圾回收需要 Full GC ，转移到堆中，只需要 Mirror GC 就可以进行回收 StringTable 中的对象。

##### 证明案例

分别在 1.6 和 1.8 的环境下向 StringTable 不断添加字符串，导致 StringTable 内存溢出。

```java
// 1.8 设置 -Xmx10m -XX:-UseGCOverheadLimit
// 1.6 设置 -XX:MaxPermSize=10m
public class JavaApp {
    public static void main(String [] args){
        List<String> list = new ArrayList<>();
        int i = 0;
        try{
            for(int j = 0;j<260000;j++){
                list.add(String.valueOf(j).intern());
                i++;
            }
        }catch (Throwable e){
            e.printStackTrace();
        }finally {
            System.out.println(i);
        }
    }
}

// 在 1.6 中为  java.lang.OutOfMemoryError: PermGen space
// 在 1.8 中为 java.lang.OutOfMemoryError: Java heap space
```



#### StringTable 垃圾回收

```java
// -Xmx10m ：设置堆内存大小
// -XX:+PrintStringTableStatistics ：打印 StringTable 统计信息
// -XX:+PrintGCDetails -verbose:gx ：打印垃圾回收信息
public class JavaApp {
    public static void main(String [] args){
        int i = 0;
        try{
            
        }catch (Throwable e){
            e.printStackTrace();
        }finally {
            System.out.println(i);
        }
    }
}
// [0.002s][warning][gc] -XX:+PrintGCDetails is deprecated. Will use -Xlog:gc* instead.
// [0.021s][info   ][gc,heap] Heap region size: 1M
// [0.022s][info   ][gc     ] Using G1
// [0.022s][info   ][gc,heap,coops] Heap address: 0x00000000ff600000, size: 10 MB, Compressed Oops mode: 32-bit
// 0
// [0.134s][info   ][gc,heap,exit ] Heap
// [0.134s][info   ][gc,heap,exit ]  garbage-first heap   total 10240K, used 1024K [0x00000000ff600000, 0x0000000100000000)
// [0.134s][info   ][gc,heap,exit ]   region size 1024K, 2 young (2048K), 0 survivors (0K)
// [0.134s][info   ][gc,heap,exit ]  Metaspace       used 6380K, capacity 6443K, committed 6528K, reserved 1056768K
// [0.134s][info   ][gc,heap,exit ]   class space    used 559K, capacity 570K, committed 640K, reserved 1048576K
// SymbolTable statistics:
// Number of buckets       :     20011 =    160088 bytes, each 8
// Number of entries       :     26605 =    638520 bytes, each 24
// Number of literals      :     26605 =   1125416 bytes, avg  42.301
// Total footprint         :           =   1924024 bytes
// Average bucket size     :     1.330
// Variance of bucket size :     1.336
// Std. dev. of bucket size:     1.156
// Maximum bucket size     :         9
// StringTable statistics:
// Number of buckets       :     65536 =    524288 bytes, each 8
// Number of entries       :      2926 =     46816 bytes, each 16
// Number of literals      :      2926 =    242696 bytes, avg  82.945 // 字符串对象数量
// Total footprsize_t         :           =    813800 bytes
// Average bucket size     :     0.045
// Variance of bucket size :     0.045
// Std. dev. of bucket size:     0.212
// Maximum bucket size     :         2
```



将大量字符串加入到 StringTable 中，会发现 StringTable 中有些字符串对象被回收了

```java
// -Xmx10m ：设置堆内存大小
// -XX:+PrintStringTableStatistics ：打印 StringTable 统计信息
// -XX:+PrintGCDetails -verbose:gx ：打印垃圾回收信息
public class JavaApp {
    public static void main(String [] args){
        int i = 0;
        try{
            for(int j = 0;j<50000;j++){
                String.valueOf(j).intern();
                i++;
            }
        }catch (Throwable e){
            e.printStackTrace();
        }finally {
            System.out.println(i);
        }
    }
}
// [0.002s][warning][gc] -XX:+PrintGCDetails is deprecated. Will use -Xlog:gc* instead.
// [0.005s][info   ][gc,heap] Heap region size: 1M
// [0.006s][info   ][gc     ] Using G1
// [0.006s][info   ][gc,heap,coops] Heap address: 0x00000000ff600000, size: 10 MB, Compressed Oops mode: 32-bit
// [0.108s][info   ][gc,start     ] GC(0) Pause Young (Normal) (G1 Evacuation Pause)
// [0.108s][info   ][gc,task      ] GC(0) Using 2 workers of 13 for evacuation
// [0.114s][info   ][gc,phases    ] GC(0)   Pre Evacuate Collection Set: 0.0ms
// [0.114s][info   ][gc,phases    ] GC(0)   Evacuate Collection Set: 6.3ms
// [0.114s][info   ][gc,phases    ] GC(0)   Post Evacuate Collection Set: 0.1ms
// [0.114s][info   ][gc,phases    ] GC(0)   Other: 0.2ms
// [0.114s][info   ][gc,heap      ] GC(0) Eden regions: 4->0(1)
// [0.114s][info   ][gc,heap      ] GC(0) Survivor regions: 0->1(1)
// [0.114s][info   ][gc,heap      ] GC(0) Old regions: 0->3
// [0.114s][info   ][gc,heap      ] GC(0) Humongous regions: 0->0
// [0.114s][info   ][gc,metaspace ] GC(0) Metaspace: 6420K->6420K(1056768K)
// [0.114s][info   ][gc           ] GC(0) Pause Young (Normal) (G1 Evacuation Pause) 4M->3M(10M) 6.590ms
// [0.114s][info   ][gc,cpu       ] GC(0) User=0.00s Sys=0.00s Real=0.01s
// 50000
// [0.117s][info   ][gc,heap,exit ] Heap
// [0.117s][info   ][gc,heap,exit ]  garbage-first heap   total 10240K, used 3100K [0x00000000ff600000, 0x0000000100000000)
// [0.117s][info   ][gc,heap,exit ]   region size 1024K, 2 young (2048K), 1 survivors (1024K)
// [0.117s][info   ][gc,heap,exit ]  Metaspace       used 6439K, capacity 6539K, committed 6784K, reserved 1056768K
// [0.117s][info   ][gc,heap,exit ]   class space    used 564K, capacity 602K, committed 640K, reserved 1048576K
// SymbolTable statistics:
// Number of buckets       :     20011 =    160088 bytes, each 8
// Number of entries       :     26688 =    640512 bytes, each 24
// Number of literals      :     26688 =   1127872 bytes, avg  42.261
// Total footprint         :           =   1928472 bytes
// Average bucket size     :     1.334
// Variance of bucket size :     1.340
// Std. dev. of bucket size:     1.158
// Maximum bucket size     :         9
// StringTable statistics:
// Number of buckets       :     65536 =    524288 bytes, each 8
// Number of entries       :     52920 =    846720 bytes, each 16
// Number of literals      :     52920 =   2642672 bytes, avg  49.937 // 字符串对象数量
// Total footprsize_t         :           =   4013680 bytes
// Average bucket size     :     0.807
// Variance of bucket size :     1.567
// Std. dev. of bucket size:     1.252
// Maximum bucket size     :         7
```



#### StringTable 性能调优

**减小哈希冲突**

-XX:StringTableSize=200000 ：设置 HashTable bucket 大小

**重复使用的字符串考虑入池**

```java
// -XX:StringTableSize=200000 ：设置 HashTable bucket 大小
// -XX:+PrintStringTableStatistics ：打印 StringTable 统计信息
public class JavaApp {
    public static void main(String [] args){
        long start = System.nanoTime();
        for(int j = 0;j<400000;j++){
            String.valueOf(j).intern();
        }
        System.out.println("cost:"+(System.nanoTime()-start)/1000000);
    }
}
// 设置 HashTable bucket 大小为 200000
// cost:90
// SymbolTable statistics:
// Number of buckets       :     20011 =    160088 bytes, each 8
// Number of entries       :     27108 =    650592 bytes, each 24
// Number of literals      :     27108 =   1149848 bytes, avg  42.417
// Total footprint         :           =   1960528 bytes
// Average bucket size     :     1.355
// Variance of bucket size :     1.359
// Std. dev. of bucket size:     1.166
// Maximum bucket size     :         9
// StringTable statistics:
// Number of buckets       :    262144 =   2097152 bytes, each 8
// Number of entries       :    402971 =   6447536 bytes, each 16
// Number of literals      :    402971 =  19446096 bytes, avg  48.257
// Total footprsize_t         :           =  27990784 bytes
// Average bucket size     :     1.537
// Variance of bucket size :     1.529
// Std. dev. of bucket size:     1.237
// Maximum bucket size     :         7

// 不设置 HashTable bucket
// cost:193
// SymbolTable statistics:
// Number of buckets       :     20011 =    160088 bytes, each 8
// Number of entries       :     27108 =    650592 bytes, each 24
// Number of literals      :     27108 =   1149848 bytes, avg  42.417
// Total footprint         :           =   1960528 bytes
// Average bucket size     :     1.355
// Variance of bucket size :     1.359
// Std. dev. of bucket size:     1.166
// Maximum bucket size     :         9
// StringTable statistics:
// Number of buckets       :     65536 =    524288 bytes, each 8
// Number of entries       :    402971 =   6447536 bytes, each 16
// Number of literals      :    402971 =  19446096 bytes, avg  48.257
// Total footprsize_t         :           =  26417920 bytes
// Average bucket size     :     6.149
// Variance of bucket size :    17.513
// Std. dev. of bucket size:     4.185
// Maximum bucket size     :        19
```



## 执行引擎

### 垃圾回收器

#### 如何判断对象可以回收

##### 引用计数法

根据对象被引用的数量决定是否回收该对象，当被引用的数量为 0 时，则可以对该对象进行垃圾回收。

###### 出现的问题

当多个对象出现循环引用时，这些对象由于被引用的数量都不可能为 0 ，所以无法回收这些对象。



##### 可达性分析算法

对堆中的对象进行扫描，判断是否能够沿着 GC Root 对象 为起点的引用链找到该对象，如果找不到，则标记当前对象为可回收对象，否则不回收当前对象。



###### 根对象（GC Root 对象）

**案例**

使用 Memory Analyzer 内存分析工具寻找根对象

**1、运行程序**

```java
public class JavaApp {

    public static void main(String [] args) throws IOException {
        List<Object> list = new ArrayList<>();
        list.add("a");
        list.add("b");
        System.out.println(1);
        System.in.read();

        list = null;
        System.out.println(2);
        System.in.read();
        System.out.println("end");
    }
}
```

**2、使用 jps 查看 java 进程**

```sh
PS D:\develop\code\java\jvm> jps
20912 Jps
21220 Launcher
8388
17708 JavaApp
```

**3、使用 jmap 抓取堆快照**

```sh
# format:二进制格式，存活的对象（抓取之前会进行一次垃圾回收），保存文件
PS D:\develop\code\java\jvm> jmap -dump:format=b,live,file=JavaApp.dump.bin 17708
Heap dump file created
# list 被置为空之后抓取
PS D:\develop\code\java\jvm> jmap -dump:format=b,live,file=JavaApp2.dump.bin 17708 
Heap dump file created
```

**4、使用 mat 打开两份堆快照**

打开 Open Query Browser -> Java Basics -> GC Roots 可以看到根对象被分为几大类

![](D:/documents/notes/pictures/20230315/012.PNG)

线程内的局部变量所引用的对象都可以作为根对象

![](D:/documents/notes/pictures/20230315/013.PNG)



当对象没有被引用时，对象将被回收

![](D:/documents/notes/pictures/20230315/014.PNG)





##### 四种引用

###### 强引用（StrongReference）

只有所有 GC Roots 对象都不通过强引用引用该对象，该对象才能被垃圾回收。

```java
Object object = new Object();
String str = "scc";
//都是强引用
```

###### 软引用(SoftReference)

仅有软引用引用该对象时，在垃圾回收后，内存仍然不足时会再次发起垃圾回收，回收软引用对象。

可以配合引用队列来释放软引用自身。

###### 软引用示例

```java
// -Xmx20m
public class JavaApp {
    private static final int _4MB = 4 * 1024 * 1024;
    public static void main(String [] args) {
        List<SoftReference<byte[]>> list = new ArrayList();
        for(int i = 0; i<5;i++){
            SoftReference<byte[]> ref = new SoftReference<>(new byte[_4MB]);
            System.out.println(ref.get());
            list.add(ref);
            System.out.println(list.size());
        }
        System.out.println("循环结束:"+list.size());
        for(SoftReference<byte[]> ref:list){
            System.out.println(ref.get());
        }
    }
}
// 结果如下
// [B@4c203ea1
// 1
// [B@27f674d
// 2
// [B@1d251891
// 3
// [B@48140564
// 4
// [B@58ceff1
// 5
// 循环结束:5
// null
// null
// null
// [B@48140564
// [B@58ceff1

// 垃圾回收详细信息
// [0.002s][warning][gc] -XX:+PrintGCDetails is deprecated. Will use -Xlog:gc* instead.
// [0.020s][info   ][gc,heap] Heap region size: 1M
// [0.021s][info   ][gc     ] Using G1
// [0.021s][info   ][gc,heap,coops] Heap address: 0x00000000fec00000, size: 20 MB, Compressed Oops mode: 32-bit
// [B@4c203ea1
// 1
// [0.147s][info   ][gc,start     ] GC(0) Pause Young (Concurrent Start) (G1 Humongous Allocation)
// [0.147s][info   ][gc,task      ] GC(0) Using 2 workers of 13 for evacuation
// [0.148s][info   ][gc,phases    ] GC(0)   Pre Evacuate Collection Set: 0.0ms
// [0.148s][info   ][gc,phases    ] GC(0)   Evacuate Collection Set: 1.3ms
// [0.148s][info   ][gc,phases    ] GC(0)   Post Evacuate Collection Set: 0.1ms
// [0.148s][info   ][gc,phases    ] GC(0)   Other: 0.2ms
// [0.148s][info   ][gc,heap      ] GC(0) Eden regions: 3->0(8)
// [0.148s][info   ][gc,heap      ] GC(0) Survivor regions: 0->1(2)
// [0.148s][info   ][gc,heap      ] GC(0) Old regions: 0->0
// [0.148s][info   ][gc,heap      ] GC(0) Humongous regions: 5->5
// [0.148s][info   ][gc,metaspace ] GC(0) Metaspace: 6369K->6369K(1056768K)
// [0.148s][info   ][gc           ] GC(0) Pause Young (Concurrent Start) (G1 Humongous Allocation) 7M->5M(20M) 1.644ms
// [0.148s][info   ][gc,cpu       ] GC(0) User=0.03s Sys=0.00s Real=0.00s
// [0.148s][info   ][gc           ] GC(1) Concurrent Cycle
// [0.148s][info   ][gc,marking   ] GC(1) Concurrent Clear Claimed Marks
// [0.149s][info   ][gc,marking   ] GC(1) Concurrent Clear Claimed Marks 0.004ms
// [0.149s][info   ][gc,marking   ] GC(1) Concurrent Scan Root Regions
// [0.150s][info   ][gc,marking   ] GC(1) Concurrent Scan Root Regions 0.861ms
// [0.150s][info   ][gc,marking   ] GC(1) Concurrent Mark (0.150s)
// [0.150s][info   ][gc,marking   ] GC(1) Concurrent Mark From Roots
// [0.150s][info   ][gc,task      ] GC(1) Using 3 workers of 3 for marking
// [0.150s][info   ][gc,marking   ] GC(1) Concurrent Mark From Roots 0.331ms
// [0.150s][info   ][gc,marking   ] GC(1) Concurrent Preclean
// [0.150s][info   ][gc,marking   ] GC(1) Concurrent Preclean 0.040ms
// [0.150s][info   ][gc,marking   ] GC(1) Concurrent Mark (0.150s, 0.150s) 0.388ms
// [B@27f674d[0.150s][info   ][gc,start     ] GC(1) Pause Remark
// [0.151s][info   ][gc,stringtable] GC(1) Cleaned string and symbol table, strings: 2932 processed, 0 removed, symbols: 26618 processed, 0 removed
// [0.151s][info   ][gc            ] GC(1) Pause Remark 11M->11M(20M) 1.032ms
// [0.151s][info   ][gc,cpu        ] GC(1) User=0.00s Sys=0.00s Real=0.00s
// [0.151s][info   ][gc,marking    ] GC(1) Concurrent Rebuild Remembered Sets
// [0.151s][info   ][gc,marking    ] GC(1) Concurrent Rebuild Remembered Sets 0.035ms
// [0.151s][info   ][gc,start      ] GC(1) Pause Cleanup
// [0.151s][info   ][gc            ] GC(1) Pause Cleanup 11M->11M(20M) 0.024ms
// [0.151s][info   ][gc,cpu        ] GC(1) User=0.00s Sys=0.00s Real=0.00s
// [0.151s][info   ][gc,marking    ] GC(1) Concurrent Cleanup for Next Mark
// 
// 2
// [0.151s][info   ][gc,marking    ] GC(1) Concurrent Cleanup for Next Mark 0.091ms
// [0.151s][info   ][gc            ] GC(1) Concurrent Cycle 2.818ms
// [B@1d251891
// 3
// [0.153s][info   ][gc,start      ] GC(2) Pause Young (Concurrent Start) (G1 Humongous Allocation)
// [0.153s][info   ][gc,task       ] GC(2) Using 2 workers of 13 for evacuation
// [0.154s][info   ][gc,phases     ] GC(2)   Pre Evacuate Collection Set: 0.0ms
// [0.154s][info   ][gc,phases     ] GC(2)   Evacuate Collection Set: 0.8ms
// [0.154s][info   ][gc,phases     ] GC(2)   Post Evacuate Collection Set: 0.1ms
// [0.154s][info   ][gc,phases     ] GC(2)   Other: 0.1ms
// [0.154s][info   ][gc,heap       ] GC(2) Eden regions: 1->0(1)
// [0.154s][info   ][gc,heap       ] GC(2) Survivor regions: 1->1(2)
// [0.154s][info   ][gc,heap       ] GC(2) Old regions: 0->0
// [0.154s][info   ][gc,heap       ] GC(2) Humongous regions: 15->15
// [0.154s][info   ][gc,metaspace  ] GC(2) Metaspace: 6419K->6419K(1056768K)
// [0.154s][info   ][gc            ] GC(2) Pause Young (Concurrent Start) (G1 Humongous Allocation) 16M->16M(20M) 1.069ms
// [0.154s][info   ][gc,cpu        ] GC(2) User=0.00s Sys=0.00s Real=0.00s
// [0.154s][info   ][gc            ] GC(3) Concurrent Cycle
// [0.154s][info   ][gc,marking    ] GC(3) Concurrent Clear Claimed Marks
// [0.154s][info   ][gc,marking    ] GC(3) Concurrent Clear Claimed Marks 0.005ms
// [0.154s][info   ][gc,marking    ] GC(3) Concurrent Scan Root Regions
// [0.155s][info   ][gc,marking    ] GC(3) Concurrent Scan Root Regions 0.545ms
// [0.155s][info   ][gc,marking    ] GC(3) Concurrent Mark (0.155s)
// [0.155s][info   ][gc,marking    ] GC(3) Concurrent Mark From Roots
// [0.155s][info   ][gc,start      ] GC(4) Pause Young (Normal) (G1 Humongous Allocation)
// [0.155s][info   ][gc,task       ] GC(3) Using 3 workers of 3 for marking
// [0.155s][info   ][gc,task       ] GC(4) Using 2 workers of 13 for evacuation
// [0.155s][info   ][gc,phases     ] GC(4)   Pre Evacuate Collection Set: 0.5ms
// [0.155s][info   ][gc,phases     ] GC(4)   Evacuate Collection Set: 0.8ms
// [0.155s][info   ][gc,phases     ] GC(4)   Post Evacuate Collection Set: 0.0ms
// [0.155s][info   ][gc,phases     ] GC(4)   Other: 0.1ms
// [0.155s][info   ][gc,heap       ] GC(4) Eden regions: 0->0(1)
// [0.155s][info   ][gc,heap       ] GC(4) Survivor regions: 1->1(1)
// [0.155s][info   ][gc,heap       ] GC(4) Old regions: 0->1
// [0.155s][info   ][gc,heap       ] GC(4) Humongous regions: 15->15
// [0.155s][info   ][gc,metaspace  ] GC(4) Metaspace: 6419K->6419K(1056768K)
// [0.155s][info   ][gc            ] GC(4) Pause Young (Normal) (G1 Humongous Allocation) 16M->16M(20M) 0.890ms
// [0.155s][info   ][gc,cpu        ] GC(4) User=0.00s Sys=0.00s Real=0.00s
// [0.156s][info   ][gc,task       ] GC(5) Using 2 workers of 13 for full compaction
// [0.156s][info   ][gc,start      ] GC(5) Pause Full (G1 Humongous Allocation)
// [0.156s][info   ][gc,phases,start] GC(5) Phase 1: Mark live objects
// [0.157s][info   ][gc,stringtable ] GC(5) Cleaned string and symbol table, strings: 2933 processed, 3 removed, symbols: 26667 processed, 0 removed
// [0.157s][info   ][gc,phases      ] GC(5) Phase 1: Mark live objects 1.068ms
// [0.157s][info   ][gc,phases,start] GC(5) Phase 2: Prepare for compaction
// [0.157s][info   ][gc,phases      ] GC(5) Phase 2: Prepare for compaction 0.168ms
// [0.157s][info   ][gc,phases,start] GC(5) Phase 3: Adjust pointers
// [0.157s][info   ][gc,phases      ] GC(5) Phase 3: Adjust pointers 0.356ms
// [0.157s][info   ][gc,phases,start] GC(5) Phase 4: Compact heap
// [0.158s][info   ][gc,phases      ] GC(5) Phase 4: Compact heap 0.205ms
// [0.158s][info   ][gc,heap        ] GC(5) Eden regions: 0->0(1)
// [0.158s][info   ][gc,heap        ] GC(5) Survivor regions: 1->0(1)
// [0.158s][info   ][gc,heap        ] GC(5) Old regions: 1->2
// [0.158s][info   ][gc,heap        ] GC(5) Humongous regions: 15->15
// [0.158s][info   ][gc,metaspace   ] GC(5) Metaspace: 6419K->6419K(1056768K)
// [0.158s][info   ][gc             ] GC(5) Pause Full (G1 Humongous Allocation) 16M->15M(20M) 2.052ms
// [0.158s][info   ][gc,cpu         ] GC(5) User=0.00s Sys=0.00s Real=0.00s
// [0.158s][info   ][gc,task        ] GC(6) Using 2 workers of 13 for full compaction
// [0.158s][info   ][gc,start       ] GC(6) Pause Full (G1 Humongous Allocation)
// [0.158s][info   ][gc,phases,start] GC(6) Phase 1: Mark live objects
// [0.159s][info   ][gc,stringtable ] GC(6) Cleaned string and symbol table, strings: 2930 processed, 2 removed, symbols: 26667 processed, 0 removed
// [0.159s][info   ][gc,phases      ] GC(6) Phase 1: Mark live objects 0.727ms
// [0.159s][info   ][gc,phases,start] GC(6) Phase 2: Prepare for compaction
// [0.159s][info   ][gc,phases      ] GC(6) Phase 2: Prepare for compaction 0.148ms
// [0.159s][info   ][gc,phases,start] GC(6) Phase 3: Adjust pointers
// [0.159s][info   ][gc,phases      ] GC(6) Phase 3: Adjust pointers 0.311ms
// [0.159s][info   ][gc,phases,start] GC(6) Phase 4: Compact heap
// [0.159s][info   ][gc,phases      ] GC(6) Phase 4: Compact heap 0.190ms
// [0.160s][info   ][gc,heap        ] GC(6) Eden regions: 0->0(1)
// [0.160s][info   ][gc,heap        ] GC(6) Survivor regions: 0->0(1)
// [0.160s][info   ][gc,heap        ] GC(6) Old regions: 2->2
// [0.160s][info   ][gc,heap        ] GC(6) Humongous regions: 15->0
// [0.160s][info   ][gc,metaspace   ] GC(6) Metaspace: 6419K->6419K(1056768K)
// [0.160s][info   ][gc             ] GC(6) Pause Full (G1 Humongous Allocation) 15M->0M(8M) 1.838ms
// [0.160s][info   ][gc,cpu         ] GC(6) User=0.00s Sys=0.00s Real=0.00s
// [0.160s][info   ][gc,marking     ] GC(3) Concurrent Mark From Roots 5.160ms
// [0.160s][info   ][gc,marking     ] GC(3) Concurrent Mark Abort
// [0.160s][info   ][gc             ] GC(3) Concurrent Cycle 5.757ms
// [B@48140564
// 4
// [0.160s][info   ][gc,start       ] GC(7) Pause Young (Concurrent Start) (G1 Humongous Allocation)
// [0.160s][info   ][gc,task        ] GC(7) Using 2 workers of 13 for evacuation
// [0.161s][info   ][gc,phases      ] GC(7)   Pre Evacuate Collection Set: 0.0ms
// [0.161s][info   ][gc,phases      ] GC(7)   Evacuate Collection Set: 0.1ms
// [0.161s][info   ][gc,phases      ] GC(7)   Post Evacuate Collection Set: 0.0ms
// [0.161s][info   ][gc,phases      ] GC(7)   Other: 0.1ms
// [0.161s][info   ][gc,heap        ] GC(7) Eden regions: 1->0(1)
// [0.161s][info   ][gc,heap        ] GC(7) Survivor regions: 0->1(1)
// [0.161s][info   ][gc,heap        ] GC(7) Old regions: 2->2
// [0.161s][info   ][gc,heap        ] GC(7) Humongous regions: 5->5
// [0.161s][info   ][gc,metaspace   ] GC(7) Metaspace: 6419K->6419K(1056768K)
// [0.161s][info   ][gc             ] GC(7) Pause Young (Concurrent Start) (G1 Humongous Allocation) 5M->5M(9M) 0.251ms
// [0.161s][info   ][gc,cpu         ] GC(7) User=0.00s Sys=0.00s Real=0.00s
// [0.161s][info   ][gc             ] GC(8) Concurrent Cycle
// [0.161s][info   ][gc,marking     ] GC(8) Concurrent Clear Claimed Marks
// [0.161s][info   ][gc,marking     ] GC(8) Concurrent Clear Claimed Marks 0.004ms
// [0.161s][info   ][gc,marking     ] GC(8) Concurrent Scan Root Regions
// [0.161s][info   ][gc,marking     ] GC(8) Concurrent Scan Root Regions 0.028ms
// [0.161s][info   ][gc,marking     ] GC(8) Concurrent Mark (0.161s)
// [0.161s][info   ][gc,marking     ] GC(8) Concurrent Mark From Roots
// [0.161s][info   ][gc,task        ] GC(8) Using 3 workers of 3 for marking
// [0.162s][info   ][gc,marking     ] GC(8) Concurrent Mark From Roots 1.270ms
// [0.162s][info   ][gc,marking     ] GC(8) Concurrent Preclean
// [0.162s][info   ][gc,marking     ] GC(8) Concurrent Preclean 0.037ms
// [0.162s][info   ][gc,marking     ] GC(8) Concurrent Mark (0.161s, 0.162s) 1.323ms
// [0.162s][info   ][gc,start       ] GC(8) Pause Remark
// [0.163s][info   ][gc,stringtable ] GC(8) Cleaned string and symbol table, strings: 2928 processed, 0 removed, symbols: 26667 processed, 0 removed
// [0.163s][info   ][gc             ] GC(8) Pause Remark 10M->10M(14M) 0.846ms
// [0.163s][info   ][gc,cpu         ] GC(8) User=0.00s Sys=0.00s Real=0.00s
// [0.163s][info   ][gc,marking     ] GC(8) Concurrent Rebuild Remembered Sets
// [B@58ceff1
// 5
// [0.163s][info   ][gc,marking     ] GC(8) Concurrent Rebuild Remembered Sets 0.426ms
// [0.164s][info   ][gc,start       ] GC(8) Pause Cleanup
// [0.164s][info   ][gc             ] GC(8) Pause Cleanup 10M->10M(14M) 0.027ms
// [0.164s][info   ][gc,cpu         ] GC(8) User=0.00s Sys=0.00s Real=0.00s
// [0.164s][info   ][gc,marking     ] GC(8) Concurrent Cleanup for Next Mark
// [0.164s][info   ][gc,marking     ] GC(8) Concurrent Cleanup for Next Mark 0.042ms
// [0.164s][info   ][gc             ] GC(8) Concurrent Cycle 2.887ms
// 循环结束:5
// null
// null
// null
// [B@48140564
// [B@58ceff1
// [0.175s][info   ][gc,heap,exit   ] Heap
// [0.175s][info   ][gc,heap,exit   ]  garbage-first heap   total 14336K, used 11241K [0x00000000fec00000, 0x0000000100000000)
// [0.175s][info   ][gc,heap,exit   ]   region size 1024K, 2 young (2048K), 1 survivors (1024K)
// [0.175s][info   ][gc,heap,exit   ]  Metaspace       used 6686K, capacity 6766K, committed 7040K, reserved 1056768K
// [0.175s][info   ][gc,heap,exit   ]   class space    used 593K, capacity 614K, committed 640K, reserved 1048576K
// 
```

###### 软引用配合引用队列使用

```java
// -Xmx20m -XX:+PrintGCDetails -verbose:gc
public class JavaApp {
    private static final int _4MB = 4 * 1024 * 1024;
    public static void main(String [] args) {
        List<SoftReference<byte[]>> list = new ArrayList();
        ReferenceQueue<byte[]> queue = new ReferenceQueue<>();
        for(int i = 0; i<5;i++){
            // 关联了引用队列，当软引用所关联的 byte[] 被垃圾回收时，软引用会自己加入到 queue 中去
            SoftReference<byte[]> ref = new SoftReference<>(new byte[_4MB], queue);
            System.out.println(ref.get());
            list.add(ref);
            System.out.println(list.size());
        }
        System.out.println("循环结束:"+list.size());

        Reference<? extends byte[]> poll = queue.poll();
        while(poll != null){
            list.remove(poll);
            poll = queue.poll();
        }

        for(SoftReference<byte[]> ref:list){
            System.out.println(ref.get());
        }
    }
}

// [B@7c75222b
// 1
// [B@4c203ea1
// 2
// [B@27f674d
// 3
// [B@1d251891
// 4
// [B@48140564
// 5
// 循环结束:5
// [B@1d251891
// [B@48140564
```



###### 弱引用(WeakReference)

仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象。

可以配合引用队列来释放弱引用自身。

###### 弱引用示例

```java
// -Xmx20m -XX:+PrintGCDetails -verbose:gc
public class JavaApp {
    private static final int _4MB = 4 * 1024 * 1024;
    public static void main(String [] args) {
        List<WeakReference<byte[]>> list = new ArrayList();
        for(int i = 0; i<5;i++){
            WeakReference<byte[]> ref = new WeakReference<>(new byte[_4MB]);
            list.add(ref);
            for(WeakReference<byte[]> w:list){
                System.out.print(w.get());
            }
            System.out.println(list.size());
        }
        System.out.println("循环结束:"+list.size());
    }
}
```



###### 弱引用配合引用队列使用

与软引用类似



###### 虚引用(PhantomReference)

- 不会决定对象的生命周期
- 任何时候都可能被垃圾收集器回收
- 跟踪对象被垃圾收集器回收的活动,起哨兵作用
- 必须和引用队列`ReferenceQueue`联合使用
- 主要用来跟踪对象被垃圾回收的活动

​    当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中。由 Reference Handler 线程调用虚引用的相关方法。

```java
Object obj = new Object();
ReferenceQueue queue = new ReferenceQueue();
PhantomReference reference = new PhantomReference(obj, queue);
//强引用对象滞空，保留软引用
obj = null;
```

###### 终结器引用

无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的finalize 方法，第二次 GC 时才能回收被引用对象。



#### 垃圾回收算法

在垃圾回收过程中垃圾回收器会根据不同的情况使用不同的垃圾回收算法

##### 标记清除

Mark Sweep

优点

速度快

缺点

会产生内存碎片



![](D:/documents/notes/pictures/20230315/015.PNG)



##### 标记整理

Mark Compact

优点

不会产生内存碎片

缺点

整理内存过程中需要移动对象，速度较慢

![](D:/documents/notes/pictures/20230315/016.PNG)

##### 复制

Copy

优点

不会产生内存碎片

缺点

需要占用双倍内存空间

![](D:/documents/notes/pictures/20230315/017.PNG)



#### 分代垃圾回收

![](D:/documents/notes/pictures/20230315/018.PNG)

- 新对象首先分配在伊甸园区域
- 新生代空间不足时，触发 Minor GC，伊甸园和幸存区 From 中存活（可达性分析算法）的对象使用复制算法复制到幸存区 To 中，存活的对象年龄加1，然后在逻辑上交换 From 和 To
- Minor GC 会引发 stop the world(STW)。暂停其它用户线程，等垃圾回收结束后，用户线程才能继续运行
- 当对象年龄超过阈值时，会晋升到老年代，最大寿命为 15。（在对象头中保存年龄的字段大小为 4bit，所以最大为 15 ）
- 当老年代空间不足时，会先尝试触发 Minor GC，如果之后空间仍不足，那么将触发 Full GC，STW 的时间更长（对象多、回收算法不同）
- Full GC 后空间仍然不足，将抛出内存不足异常



##### 相关 JVM 参数

| 含义                | 参数                                                        |
| ------------------- | ----------------------------------------------------------- |
| 堆初始大小          | -Xms                                                        |
| 堆最大大小          | -Xmx 或 -XX:MaxHeapSize=size                                |
| 新生代大小          | -Xmn 或 -XX:NewSize=size + -XX:MaxNewSize=size              |
| 幸存区比例（动态）  | -XX:InitialSurvivorRatio=ratio 和 -XX:UseAdaptiveSizePolicy |
| 幸存区比例          | -XX:SurvivorRatio=ratio（伊甸园的占比）                     |
| 晋升阈值            | -XX:MaxTenuringThreshold=threshold                          |
| 晋升详情            | -XX:PrintTenuringDistribution                               |
| GC 详情             | -XX:PrintGCDetails -verbose:gc                              |
| Full GC 前 Minor GC | -XX:+ScavengeBeforeFullGC                                   |



##### GC 分析

###### 不进行垃圾回收

伊甸园存放初始对象，占用 28%

幸存区 from 、幸存区 to 占用 0%

```java
// -Xms20m -Xmx20m -Xmn10m -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc
public class JavaApp {
    private static final int _512KB = 512 * 1024;
    private static final int _1MB = 1024 * 1024;
    private static final int _6MB = 6 * _1MB;
    private static final int _7MB = 7 * _1MB;
    private static final int _8MB = 8 * _1MB;
    public static void main(String [] args) {
        
    }
}

// [0.003s][warning][gc] -XX:+PrintGCDetails is deprecated. Will use -Xlog:gc* instead.
// [0.034s][info   ][gc] Using Serial
// [0.034s][info   ][gc,heap,coops] Heap address: 0x00000000fec00000, size: 20 MB, Compressed Oops mode: 32-bit
// [0.159s][info   ][gc,heap,exit ] Heap
// [0.159s][info   ][gc,heap,exit ]  def new generation   total 9216K, used 2351K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
// [0.159s][info   ][gc,heap,exit ]   eden space 8192K,  28% used [0x00000000fec00000, 0x00000000fee4bf00, 0x00000000ff400000)
// [0.159s][info   ][gc,heap,exit ]   from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
// [0.159s][info   ][gc,heap,exit ]   to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)
// [0.159s][info   ][gc,heap,exit ]  tenured generation   total 10240K, used 0K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
// [0.159s][info   ][gc,heap,exit ]    the space 10240K,   0% used [0x00000000ff600000, 0x00000000ff600000, 0x00000000ff600200, 0x0000000100000000)
// [0.159s][info   ][gc,heap,exit ]  Metaspace       used 6371K, capacity 6443K, committed 6528K, reserved 1056768K
// [0.159s][info   ][gc,heap,exit ]   class space    used 559K, capacity 570K, committed 640K, reserved 1048576K
```

###### 一次垃圾回收

新增 7 MB 对象

先对新生代进行垃圾回收，2351K->966K

不能被回收的对象放在幸存区 from，占用 94%

新对象放在伊甸园，占用 92%

```java
// -Xms20m -Xmx20m -Xmn10m -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc
public class JavaApp {
    private static final int _512KB = 512 * 1024;
    private static final int _1MB = 1024 * 1024;
    private static final int _6MB = 6 * _1MB;
    private static final int _7MB = 7 * _1MB;
    private static final int _8MB = 8 * _1MB;
    public static void main(String [] args) {
        List<byte[]> list = new ArrayList<>();
        list.add(new byte[_7MB]);
    }
}

// [0.003s][warning][gc] -XX:+PrintGCDetails is deprecated. Will use -Xlog:gc* instead.
// [0.006s][info   ][gc] Using Serial
// [0.006s][info   ][gc,heap,coops] Heap address: 0x00000000fec00000, size: 20 MB, Compressed Oops mode: 32-bit
// [0.093s][info   ][gc,start     ] GC(0) Pause Young (Allocation Failure)
// [0.094s][info   ][gc,heap      ] GC(0) DefNew: 2351K->966K(9216K)
// [0.094s][info   ][gc,heap      ] GC(0) Tenured: 0K->0K(10240K)
// [0.094s][info   ][gc,metaspace ] GC(0) Metaspace: 6386K->6386K(1056768K)
// [0.094s][info   ][gc           ] GC(0) Pause Young (Allocation Failure) 2M->0M(19M) 1.597ms
// [0.094s][info   ][gc,cpu       ] GC(0) User=0.00s Sys=0.00s Real=0.00s
// [0.096s][info   ][gc,heap,exit ] Heap
// [0.096s][info   ][gc,heap,exit ]  def new generation   total 9216K, used 8517K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
// [0.096s][info   ][gc,heap,exit ]   eden space 8192K,  92% used [0x00000000fec00000, 0x00000000ff35fb00, 0x00000000ff400000)
// [0.096s][info   ][gc,heap,exit ]   from space 1024K,  94% used [0x00000000ff500000, 0x00000000ff5f1a80, 0x00000000ff600000)
// [0.096s][info   ][gc,heap,exit ]   to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
// [0.096s][info   ][gc,heap,exit ]  tenured generation   total 10240K, used 0K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
// [0.096s][info   ][gc,heap,exit ]    the space 10240K,   0% used [0x00000000ff600000, 0x00000000ff600000, 0x00000000ff600200, 0x0000000100000000)
// [0.096s][info   ][gc,heap,exit ]  Metaspace       used 6434K, capacity 6539K, committed 6784K, reserved 1056768K
// [0.096s][info   ][gc,heap,exit ]   class space    used 564K, capacity 602K, committed 640K, reserved 1048576K
```

###### 两次垃圾回收

第一次垃圾回收：幸存对象放在幸存区 from

第二次垃圾回收：发现新生代放不下 7MB 的大对象，直接将大对象放在老年代

```java
// -Xms20m -Xmx20m -Xmn10m -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc
public class JavaApp {
    private static final int _512KB = 512 * 1024;
    private static final int _1MB = 1024 * 1024;
    private static final int _6MB = 6 * _1MB;
    private static final int _7MB = 7 * _1MB;
    private static final int _8MB = 8 * _1MB;
    public static void main(String [] args) {
        List<byte[]> list = new ArrayList<>();
        list.add(new byte[_7MB]);
        list.add(new byte[_1MB]);
    }
}

// [0.002s][warning][gc] -XX:+PrintGCDetails is deprecated. Will use -Xlog:gc* instead.
// [0.006s][info   ][gc] Using Serial
// [0.006s][info   ][gc,heap,coops] Heap address: 0x00000000fec00000, size: 20 MB, Compressed Oops mode: 32-bit
// [0.097s][info   ][gc,start     ] GC(0) Pause Young (Allocation Failure)
// [0.098s][info   ][gc,heap      ] GC(0) DefNew: 2351K->967K(9216K)
// [0.098s][info   ][gc,heap      ] GC(0) Tenured: 0K->0K(10240K)
// [0.098s][info   ][gc,metaspace ] GC(0) Metaspace: 6393K->6393K(1056768K)
// [0.098s][info   ][gc           ] GC(0) Pause Young (Allocation Failure) 2M->0M(19M) 1.501ms
// [0.098s][info   ][gc,cpu       ] GC(0) User=0.02s Sys=0.00s Real=0.00s
// [0.100s][info   ][gc,start     ] GC(1) Pause Young (Allocation Failure)
// [0.104s][info   ][gc,heap      ] GC(1) DefNew: 8462K->24K(9216K)
// [0.104s][info   ][gc,heap      ] GC(1) Tenured: 0K->8134K(10240K)
// [0.104s][info   ][gc,metaspace ] GC(1) Metaspace: 6413K->6413K(1056768K)
// [0.104s][info   ][gc           ] GC(1) Pause Young (Allocation Failure) 8M->7M(19M) 3.613ms
// [0.104s][info   ][gc,cpu       ] GC(1) User=0.00s Sys=0.00s Real=0.00s
// [0.104s][info   ][gc,heap,exit ] Heap
// [0.104s][info   ][gc,heap,exit ]  def new generation   total 9216K, used 1265K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
// [0.104s][info   ][gc,heap,exit ]   eden space 8192K,  15% used [0x00000000fec00000, 0x00000000fed362b0, 0x00000000ff400000)
// [0.104s][info   ][gc,heap,exit ]   from space 1024K,   2% used [0x00000000ff400000, 0x00000000ff4062c0, 0x00000000ff500000)
// [0.104s][info   ][gc,heap,exit ]   to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)
// [0.104s][info   ][gc,heap,exit ]  tenured generation   total 10240K, used 8134K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
// [0.104s][info   ][gc,heap,exit ]    the space 10240K,  79% used [0x00000000ff600000, 0x00000000ffdf1818, 0x00000000ffdf1a00, 0x0000000100000000)
// [0.104s][info   ][gc,heap,exit ]  Metaspace       used 6428K, capacity 6539K, committed 6784K, reserved 1056768K
// [0.104s][info   ][gc,heap,exit ]   class space    used 564K, capacity 602K, committed 640K, reserved 1048576K
```

###### 大对象

发现新生代放不下 8MB 的大对象，直接将大对象放在老年代，而不是将大对象放在新生代

```java
// -Xms20m -Xmx20m -Xmn10m -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc
public class JavaApp {
    private static final int _512KB = 512 * 1024;
    private static final int _1MB = 1024 * 1024;
    private static final int _6MB = 6 * _1MB;
    private static final int _7MB = 7 * _1MB;
    private static final int _8MB = 8 * _1MB;
    public static void main(String [] args) {
        List<byte[]> list = new ArrayList<>();
        list.add(new byte[_8MB]);
    }
}

// [0.002s][warning][gc] -XX:+PrintGCDetails is deprecated. Will use -Xlog:gc* instead.
// [0.006s][info   ][gc] Using Serial
// [0.006s][info   ][gc,heap,coops] Heap address: 0x00000000fec00000, size: 20 MB, Compressed Oops mode: 32-bit
// [0.097s][info   ][gc,heap,exit ] Heap
// [0.097s][info   ][gc,heap,exit ]  def new generation   total 9216K, used 2515K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
// [0.097s][info   ][gc,heap,exit ]   eden space 8192K,  30% used [0x00000000fec00000, 0x00000000fee74e80, 0x00000000ff400000)
// [0.097s][info   ][gc,heap,exit ]   from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
// [0.097s][info   ][gc,heap,exit ]   to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)
// [0.097s][info   ][gc,heap,exit ]  tenured generation   total 10240K, used 8192K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
// [0.097s][info   ][gc,heap,exit ]    the space 10240K,  80% used [0x00000000ff600000, 0x00000000ffe00010, 0x00000000ffe00200, 0x0000000100000000)
// [0.097s][info   ][gc,heap,exit ]  Metaspace       used 6433K, capacity 6539K, committed 6784K, reserved 1056768K
// [0.097s][info   ][gc,heap,exit ]   class space    used 564K, capacity 602K, committed 640K, reserved 1048576K
```

###### 大对象OOM

存放第二个大对象时先触发了新生代 GC 后触发 Full GC 后发现内存还是不足导致 OOM。

```java
// -Xms20m -Xmx20m -Xmn10m -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc
public class JavaApp {
    private static final int _512KB = 512 * 1024;
    private static final int _1MB = 1024 * 1024;
    private static final int _6MB = 6 * _1MB;
    private static final int _7MB = 7 * _1MB;
    private static final int _8MB = 8 * _1MB;
    public static void main(String [] args) {
        List<byte[]> list = new ArrayList<>();
        list.add(new byte[_8MB]);
        list.add(new byte[_8MB]);
    }
}

// [0.002s][warning][gc] -XX:+PrintGCDetails is deprecated. Will use -Xlog:gc* instead.
// [0.006s][info   ][gc] Using Serial
// [0.006s][info   ][gc,heap,coops] Heap address: 0x00000000fec00000, size: 20 MB, Compressed Oops mode: 32-bit
// [0.095s][info   ][gc,start     ] GC(0) Pause Young (Allocation Failure)
// [0.096s][info   ][gc,start     ] GC(1) Pause Full (Allocation Failure)
// [0.096s][info   ][gc,phases,start] GC(1) Phase 1: Mark live objects
// [0.098s][info   ][gc,phases      ] GC(1) Phase 1: Mark live objects 1.356ms
// [0.098s][info   ][gc,phases,start] GC(1) Phase 2: Compute new object addresses
// [0.098s][info   ][gc,phases      ] GC(1) Phase 2: Compute new object addresses 0.113ms
// [0.098s][info   ][gc,phases,start] GC(1) Phase 3: Adjust pointers
// [0.098s][info   ][gc,phases      ] GC(1) Phase 3: Adjust pointers 0.357ms
// [0.098s][info   ][gc,phases,start] GC(1) Phase 4: Move objects
// [0.099s][info   ][gc,phases      ] GC(1) Phase 4: Move objects 0.455ms
// [0.099s][info   ][gc             ] GC(1) Pause Full (Allocation Failure) 8M->8M(19M) 2.371ms
// [0.099s][info   ][gc,heap        ] GC(0) DefNew: 2351K->0K(9216K)
// [0.099s][info   ][gc,heap        ] GC(0) Tenured: 8192K->9183K(10240K)
// [0.099s][info   ][gc,metaspace   ] GC(0) Metaspace: 6418K->6418K(1056768K)
// [0.099s][info   ][gc             ] GC(0) Pause Young (Allocation Failure) 10M->8M(19M) 3.914ms
// [0.099s][info   ][gc,cpu         ] GC(0) User=0.00s Sys=0.00s Real=0.00s
// [0.099s][info   ][gc,start       ] GC(2) Pause Full (Allocation Failure)
// [0.099s][info   ][gc,phases,start] GC(2) Phase 1: Mark live objects
// [0.100s][info   ][gc,phases      ] GC(2) Phase 1: Mark live objects 0.726ms
// [0.100s][info   ][gc,phases,start] GC(2) Phase 2: Compute new object addresses
// [0.100s][info   ][gc,phases      ] GC(2) Phase 2: Compute new object addresses 0.112ms
// [0.100s][info   ][gc,phases,start] GC(2) Phase 3: Adjust pointers
// [0.100s][info   ][gc,phases      ] GC(2) Phase 3: Adjust pointers 0.345ms
// [0.100s][info   ][gc,phases,start] GC(2) Phase 4: Move objects
// [0.100s][info   ][gc,phases      ] GC(2) Phase 4: Move objects 0.111ms
// [0.100s][info   ][gc,heap        ] GC(2) DefNew: 0K->0K(9216K)
// [0.100s][info   ][gc,heap        ] GC(2) Tenured: 9183K->9169K(10240K)
// [0.100s][info   ][gc,metaspace   ] GC(2) Metaspace: 6418K->6418K(1056768K)
// [0.100s][info   ][gc             ] GC(2) Pause Full (Allocation Failure) 8M->8M(19M) 1.385ms
// [0.100s][info   ][gc,cpu         ] GC(2) User=0.00s Sys=0.00s Real=0.00s
// [0.101s][info   ][gc,heap,exit   ] Heap
// [0.101s][info   ][gc,heap,exit   ]  def new generation   total 9216K, used 218K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
// [0.101s][info   ][gc,heap,exit   ]   eden space 8192K,   2% used [0x00000000fec00000, 0x00000000fec36b58, 0x00000000ff400000)
// [0.101s][info   ][gc,heap,exit   ]   from space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)
// [0.101s][info   ][gc,heap,exit   ]   to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
// [0.101s][info   ][gc,heap,exit   ]  tenured generation   total 10240K, used 9169K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
// [0.101s][info   ][gc,heap,exit   ]    the space 10240K,  89% used [0x00000000ff600000, 0x00000000ffef4618, 0x00000000ffef4800, 0x0000000100000000)
// [0.101s][info   ][gc,heap,exit   ]  Metaspace       used 6437K, capacity 6539K, committed 6784K, reserved 1056768K
// [0.101s][info   ][gc,heap,exit   ]   class space    used 565K, capacity 602K, committed 640K, reserved 1048576K
// Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
// 	at JavaApp.main(JavaApp.java:14)
// 
// Process finished with exit code 1
```

###### 子线程 OOM 不会影响到主线程

```java
// -Xms20m -Xmx20m -Xmn10m -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc
public class JavaApp {
    private static final int _512KB = 512 * 1024;
    private static final int _1MB = 1024 * 1024;
    private static final int _6MB = 6 * _1MB;
    private static final int _7MB = 7 * _1MB;
    private static final int _8MB = 8 * _1MB;
    public static void main(String [] args) throws InterruptedException {
        new Thread(()->{
            List<byte[]> list = new ArrayList<>();
            list.add(new byte[_8MB]);
            list.add(new byte[_8MB]);
        }).start();
        Thread.sleep(5000L);
    }
}

```



#### 垃圾回收器

##### 串行（Serial GC）

单线程

堆内存较小

Serial：新生代垃圾回收（复制回收算法）

SerialOld：老年代垃圾回收（标记整理回收算法）

![](D:/documents/notes/pictures/20230315/019.PNG)



##### 吞吐量优先（Parallel GC）

多线程

堆内存较大，多核 CPU

在单位时间内，STW 的时间最短

1.8 默认垃圾回收器

-XX:+UseParalleGC：新生代垃圾回收（复制回收算法），并行，垃圾回收过程用户线程不能同时运行

-XX:+UseParalleOlGC：老年代垃圾回收（标记整理回收算法），并行，垃圾回收过程用户线程不能同时运行

-XX:UseAdaptiveSizePolicy：动态调整幸存区比例

-XX:GCTimeRatio： 默认99，1/(1+ratio)*运行时间=垃圾回收最长时间，如果垃圾回收时长超过垃圾回收最长时间则会增大堆空间大小

-XXMaxGCPauseMillis：每次垃圾回收最长时间，如果垃圾回收时长超过每次垃圾回收最长时间则会减小堆空间大小

-XX:ParallelGCThreads：指定垃圾回收工作线程数

![](D:/documents/notes/pictures/20230315/020.PNG)





##### 响应时间优先（CMS）

多线程

堆内存较大，多核 CPU

尽可能让单次 STW 的时间最短

-XX:+UseParNewGC：新生代垃圾回收（复制回收算法）

-XX:+UseConcMarkSweepGC：老年代垃圾回收（标记清除回收算法），并发，垃圾回收过程的某些阶段用户线程也能同时运行。标记清除回收算法会产生比较多的内存碎片导致并发回收失败的问题，这时候会使用串行垃圾回收 SerialOld 进行垃圾回收

-XX:ParallelGCThreads：并行线程数

=XX:ConcGCThreads：并发线程数=XX:ParallelGCThreads*0.25

-XX:CMSInitiatingOccupancyFraction：进行垃圾回收的垃圾空间占比

-XX:+CMSScanvengeBeforeRemark：在重新标记前对新生代进行一次垃圾回收

![](D:/documents/notes/pictures/20230315/021.PNG)

初始标记：标记根对象

并发标记：标记

重新标记：



##### G1

###### 定义：Garbage First

- 2004 论文发布
- 2009 JDK 6u14 体验
- 2012 JDK 7u4 官方支持
- 2017 JDK 9 默认



###### 适用场景

同时注重吞吐量（Throughput）和低延迟（Low Latency），默认的暂停目标是 200 ms

超大堆内存，会将堆划分为多个大小相等的 Region

整体上是标记+整理算法，两个区域之间是复制算法



###### 相关 JVM 参数

| 含义                              | 参数                                       |
| --------------------------------- | ------------------------------------------ |
| 开启 G1 垃圾回收器                | -XX:+UseG1GC                               |
| 堆区域大小（2 的 n 次幂 MB）      | -XX:G1HeapRegionSize=size                  |
| 垃圾回收暂停目标                  | -XX:MaxGCPauseMillis=time                  |
| 老年代进行并发标记阈值（默认45%） | -XX:InitiatingHeapOccupancyPercent=percent |



###### G1 垃圾回收过程

![](D:/documents/notes/pictures/20230315/022.PNG)

先对新生代进行垃圾回收，经过一段时间后老年代的垃圾积累变多之后（达到某个阈值），在新生代垃圾回收的同时对老年代的垃圾对象进行标记，标记完成之后对新生代和老年代同时进行垃圾回收。



###### Young Collection

堆内存分为多个区域（Region），每个区域都独立作为伊甸园、幸存区和老年代。



![](D:/documents/notes/pictures/20230315/023.jpg)

当新生代堆内存达到阈值时进行垃圾回收，使用复制算法将存活对象复制到幸存区

![image-20220725221339123](D:/documents/notes/pictures/20230315/024.jpg)

经过多次新生代垃圾回收，一部分幸存区对象晋升到老年代

![image-20220725221727044](D:/documents/notes/pictures/20230315/025.jpg)



###### Young Collection 跨代引用

新生代回收的跨代引用（老年代引用新生代）问题

![image-20220726221009543](D:/documents/notes/pictures/20230315/028.jpg)



- 卡表 Remembered Set
- 在引用表更时通过 post-write barrier + dirty card queue
- concurrent refinement threads 更新 Remembered Set

![image-20220726221426697](D:/documents/notes/pictures/20230315/029.jpg)



###### Young Collection + Concurrent Mark

在 Young GC 时会进行 GC Root 的初始标记

老年代占用空间比例达到阈值时，进行并发标记（不会 STW）

-XX:InitiatingHeapOccupancyPercent=percent（默认45%）

![image-20220725222216767](D:/documents/notes/pictures/20230315/026.jpg)



###### Mixed Collection

会对 E、S、O 区域进行全面垃圾回收

最终标记（Remark）会 STW

拷贝存活（Evacuation）会 STW

老年代的垃圾回收会根据最大暂停时间进行有选择的垃圾回收，优先回收价值高的区域

-XX:MaxGCPauseMillis=ms

![image-20220725223044911](D:/documents/notes/pictures/20230315/027.jpg)



###### Remark

pre-write barrier + satb_mark_queue





![image-20220726221946069](D:/documents/notes/pictures/20230315/030.jpg)





##### Full GC

###### Serial GC

- 新生代内存不足发生的垃圾收集 - minor gc
- 老年代内存不足发生的垃圾收集 - full gc

###### Parallel GC

- 新生代内存不足发生的垃圾收集 - minor gc
- 老年代内存不足发生的垃圾收集 - full gc

###### CMS

- 新生代内存不足发生的垃圾收集 - minor gc
- 老年代内存不足（当并发标记时回收的速度比垃圾产生的速度快时不会产生 Full GC，当由于并发回收失败时，才会产生 Full GC）

###### G1

- 新生代内存不足发生的垃圾收集 - minor gc
- 老年代内存不足（当并发标记时回收的速度比垃圾产生的速度快时不会产生 Full GC，当由于并发回收失败时，才会产生 Full GC）



##### G1 优化

###### JDK 8u20 字符串去重

- 优点：节省大量内存
- 缺点：略微多占用了 cpu 时间，新生代回收时间略微增加

-XX:+UseStringDeduplication

```java
String s1 = new String("hello"); // char[]{'h','e','l','l','o'}
String s2 = new String("hello"); // char[]{'h','e','l','l','o'}
```



- 将所有新分配的字符串放入一个队列
- 当新生代回收时，G1 并发检查是否有字符串重复
- 如果他们的值一样，让他们引用同一个 char[]
- 注意，与String.intern()不一样，String.intern()关注的是字符串对象，而字符串去重关注的是 char[]，在 JAVA 内部，使用了不同的字符串表



###### JDK 8u40 并发标记类卸载

所有对象都经过并发标记后，就能知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸载它所加载的所有类

-XX:+ClassUnloadingWithConcurrentMark 默认启用



###### JDK 8u60 回收巨型对象

一个对象大于 Region 的一半时，称之为巨型对象

G1 不会对巨型对象进行拷贝

回收时被优先考虑

G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为0的巨型对象就可以在新生代垃圾回收时处理掉



###### JDK 9 并发标记起始时间的调整

- 并发标记必须在堆空间占满前完成，否则退化为 Full GC
- JDK 9 之前需要使用 -XX:InitiatingHeapOccupancyPercent
- JDK 9 可以动态调整 -XX:InitiatingHeapOccupancyPercent 用来设置初始值，进行数据采样并动态调整，总会添加一个安全的空档空间



###### JDK 9 更高效的回收

- 250+增强
- 180+bug修复

https://docs.oracle.com/en/java/javase/12/gctuning





###### JDK 9 更高效的回收





#### 垃圾回收器调优

java -XX:+PrintFlagsFinal -version | findstr "GC"

##### 新生代调优

新生代特点：

所有的 new 操作的内存分配非常廉价，线程内 new 的对象会保存在属于线程的一块内存

TLAB(thread-local allocation buffer)

死亡对象的回收代价时零

大部分对象用过即死

Minor GC 的时间远远低于 Full GC

Oracle 推荐设置新生代大小为整个堆空间的 25% ~ 50%

新生代能容纳所有 【并发量*（请求-响应）】的数据

幸存区大到能保留【当前活跃对象+需要晋升对象】

晋升阈值配置得当，让长时间存活对象尽快晋升

对象晋升阈值 -XX:MaxTenuringThreshold=threshold

打印存活对象信息 -XX:+PrintTenuringDistribution



##### 老年代调优

老年代的内存越大越好

先不尝试做调优，如果有 Full GC 则先尝试调优新生代

观察发生 Full GC 时老年代内存占用，将老年代内存预设调大 1/4 ~ 1/3

老年代垃圾回收内存占用阈值 -XX:CMSInitiatingOccupancyFraction=percent



##### 案例

案例1 Full GC 和 Minor GC 频繁（由于新生代过小，导致年龄未够的新生代对象提前晋升老年代。解决方案：调大新生代大小）

案例2 请求高峰期发生 Full GC，单次暂停时间特别长（CMS，CMS 重新标记阶段对象过多导致标记时间过长，使用 -XX:+CMSScavengeBeForeRemark 开启重新标记前进行新生代垃圾回收，减少标记对象数量）

案例3 老年代充裕的情况下，发生 Full GC（CMS jdk1.7，元空间内存不足导致 Full GC，增大元空间大小）



## 类加载与字节码技术

### 类加载器

以 JDK 8 为例

| 名称                    | 加载哪的类            | 说明                          |
| ----------------------- | --------------------- | ----------------------------- |
| Bootstrap ClassLoader   | JAVA_HOME/jre/lib     | 无法直接访问                  |
| Extension ClassLoader   | JAVA_HOME/jre/lib/ext | 上级为 Bootstrap，显示为 null |
| Application ClassLoader | classpath             | 上级为 Extension              |
| 自定义加载器            | 自定义                | 上级为 Application            |



#### 启动类加载器

用 Bootstrap 类加载器加载类

```java
package load;

public class F {
    static {
        System.out.println("bootstarp F init");
    }
}

public class JavaApp {

    public static void main(String [] args) throws ClassNotFoundException {
        Class<?> clazz = Class.forName("load.F");
        System.out.println(clazz.getClassLoader());
    }
}

// 输出
// bootstarp F init
```

输出

```shell
# 在字节码输出目录执行
java -Xbootclasspath/a:. JavaApp
bootstarp F init
null
```



- -Xbootclasspath 表示设置 bootclasspath
- /a:. 表示将当前目录追加至 bootclasspath 之后
- 可以用这个办法替换核心类

  - java -Xbootclasspath:<new bootclasspath> ，完全替换掉原有加载路径

  - java -Xbootclasspath/a:<追加路径> ，后追加加载路径

  - java -Xbootclasspath/p:<追加路径> ，前追加加载路径



#### 扩展类加载器

```java
package load;

public class G {
    static {
        System.out.println("classpath G init");
    }
}

public class JavaApp {

    public static void main(String [] args) throws ClassNotFoundException {
        Class<?> clazz = Class.forName("load.G");
        System.out.println(clazz.getClassLoader());
    }
}

// 直接运行输出
// classpath G init
// sun.misc.Launcher$AppClassLoader@18b4aac2
```

然后修改一下 G 类的初始化输出并打包，然后放在目录 JAVA_HOME/jre/lib/ext 下

jar -cvf my.jar load\G.class

```java
package load;

public class G {
    static {
        System.out.println("ext G init");
    }
}
```

再运行一次程序，输出为

```shell
ext G init
sun.misc.Launcher$ExtClassLoader@330bedb4
```

说明加载的是扩展目录下的类，而不是自定义类。通过双亲委派模式加载了扩展目录下的 G 类。



#### 线程上下文类加载器

我们在使用 JDBC 时，都需要加载 Driver 驱动，不知道你有没有注意到，不写

```java
Class.forName("com.mysql.jdbs.Driver")
```

也是可以让 com.mysql.jdbc.Driver 正确加载的，你知道怎么做的吗？

我们追踪一下源码：

```java
public class DriverManager {
    // 注册驱动的集合
    private final static CopyOnWriteArrayList<DriverInfo> registeredDrivers = new CopyOnWriteArrayList<>();
    /**
     * 初始化驱动
     *
     */
    static {
        loadInitialDrivers();
        println("JDBC DriverManager initialized");
    }
}
```

看看 DriverManager 的类加载器

```java
System.out.println(DriverManager.class.getClassLoader());
// null
```

输出 null，表示它的类加载器是 Bootstrap ClassLoader，会到 JAVA_HOME/jre/lib 下搜索类，但 JAVA_HOME/jre/lib 下显然没有 mysql jdbc 的 jar 包，这样问题来了，在 DriverManager 的静态代码块中，怎么能正确加载 com.mysql.jdbs.Driver 呢？

继续看 loadInitialDrivers() 方法：

```java
    private static void loadInitialDrivers() {
        String drivers;
        try {
            drivers = AccessController.doPrivileged(new PrivilegedAction<String>() {
                public String run() {
                    return System.getProperty("jdbc.drivers");
                }
            });
        } catch (Exception ex) {
            drivers = null;
        }
        // If the driver is packaged as a Service Provider, load it.
        // Get all the drivers through the classloader
        // exposed as a java.sql.Driver.class service.
        // ServiceLoader.load() replaces the sun.misc.Providers()
		// 1) 使用 ServiceLoader 机制加载驱动，即 SPI
        AccessController.doPrivileged(new PrivilegedAction<Void>() {
            public Void run() {

                ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class);
                Iterator<Driver> driversIterator = loadedDrivers.iterator();

                /* Load these drivers, so that they can be instantiated.
                 * It may be the case that the driver class may not be there
                 * i.e. there may be a packaged driver with the service class
                 * as implementation of java.sql.Driver but the actual class
                 * may be missing. In that case a java.util.ServiceConfigurationError
                 * will be thrown at runtime by the VM trying to locate
                 * and load the service.
                 *
                 * Adding a try catch block to catch those runtime errors
                 * if driver not available in classpath but it's
                 * packaged as service and that service is there in classpath.
                 */
                try{
                    while(driversIterator.hasNext()) {
                        driversIterator.next();
                    }
                } catch(Throwable t) {
                // Do nothing
                }
                return null;
            }
        });

        println("DriverManager.initialize: jdbc.drivers = " + drivers);
		// 2) 使用 jdbc.drivers 定义的驱动名加载驱动
        if (drivers == null || drivers.equals("")) {
            return;
        }
        String[] driversList = drivers.split(":");
        println("number of Drivers:" + driversList.length);
        for (String aDriver : driversList) {
            try {
                println("DriverManager.Initialize: loading " + aDriver);
                // 这里的 ClassLoader.getSystemClassLoader()就是应用程序类加载器
                Class.forName(aDriver, true,
                        ClassLoader.getSystemClassLoader());
            } catch (Exception ex) {
                println("DriverManager.Initialize: load failed: " + ex);
            }
        }
    }
```

这里打破了双亲委派模式，DriverManager 使用的是启动类加载器加载，与 DriverManager 相关的类也应当使用启动类加载器加载。但是这里使用了应用程序加载器加载



##### ServiceLoader

ServiceLoader 实现了大名鼎鼎的 Service Provider Interface (SPI)

约定如下，在 jar 包的 META-INF/service 包下，以接口全限定名名为文件，文件内容是实现类名称

这样就可以使用

```java
ServiceLoader<接口类型> allImpls = ServiceLoader.load(接口类型.class);
Iterator<接口类型> iter = allImpls.iterator();
while(iter.hasNext()){
    iter.next();
}
```

通过 load 方法在文件中找到实现类，体现的是【面向接口编程+解耦】的思想，在下面一些框架中运用了此思想：

- JDBC
- Servlet 初始化器
- Spring 容器
- Dubbo （对 SPI 进行了扩展）

接着看 ServiceLoader.load 方法：

```java
public static <S> ServiceLoader<S> load(Class<S> service) {
    // 获取线程上下文类加载器
    ClassLoader cl = Thread.currentThread().getContextClassLoader();
    return ServiceLoader.load(service, cl);
}
```

线程上下文类加载器是当前线程使用的类加载器，默认就是应用程序类加载器，它内部又是由 Class.forName 调用了线程上下文类加载器完成类加载，具体代码在 ServiceLoader 的内部类 LazyIterator 中：

```java
private S nextService() {
    if (!hasNextService())
        throw new NoSuchElementException();
    String cn = nextName;
    nextName = null;
    Class<?> c = null;
    try {
        c = Class.forName(cn, false, loader);
    } catch (ClassNotFoundException x) {
        fail(service,
             "Provider " + cn + " not found");
    }
    if (!service.isAssignableFrom(c)) {
        fail(service,
             "Provider " + cn  + " not a subtype");
    }
    try {
        S p = service.cast(c.newInstance());
        providers.put(cn, p);
        return p;
    } catch (Throwable x) {
        fail(service,
             "Provider " + cn + " could not be instantiated",
             x);
    }
    throw new Error();          // This cannot happen
}
```



#### 自定义类加载器

##### 什么时候需要自定义类加载器 

- 想加载非classpath随意路径中的类文件
- 都是通过接口来使用实现，希望解藕时，常用在框架设计
- 这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于tomcat容器



##### 步骤

- 继承ClassLoader父类 
- 要遵从双亲委派机制，重写 findclass 方法
  - 注意不是重写 IoadClass 方法．否则不会走双亲委派机制
- 读取类文件的字节码
- 调用父类的 defineClass 方法来加载类
- 使用者调用该类加载器的 IoadClass 方法

##### 示例

###### 准备

准备好两个类文件放入 C:\Users\young\Desktop\temp\files\class 它实现了 java.util.Map 接口

```java
import java.util.AbstractMap;
import java.util.Map;
import java.util.Set;

public class MapImpl1 extends AbstractMap implements Map {

    static {
        System.out.println("MapImpl1 init");
    }

    @Override
    public Set<Entry> entrySet() {
        return null;
    }
}

import java.util.AbstractMap;
import java.util.Map;
import java.util.Set;

public class MapImpl2 extends AbstractMap implements Map {

    static {
        System.out.println("MapImpl2 init");
    }

    @Override
    public Set<Entry> entrySet() {
        return null;
    }
}

```

###### 编译

```shell
C:\Users\young\Desktop\temp\files\class>E:\Applications\Portable\Oracle\JDK\8u301\bin\javac MapImpl1.java

C:\Users\young\Desktop\temp\files\class>E:\Applications\Portable\Oracle\JDK\8u301\bin\javac MapImpl2.java
```



###### 定义类加载器

```java
package load;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

public class MyClassLoader extends ClassLoader{
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        String path = "C:\\Users\\young\\Desktop\\temp\\files\\class\\"+name+".class";
        ByteArrayOutputStream os = new ByteArrayOutputStream();
        try {
            Files.copy(Paths.get(path), os);
        } catch (IOException e) {
            e.printStackTrace();
            throw new ClassNotFoundException("类文件未找到", e);
        }
        byte[] bytes = os.toByteArray();
        return defineClass(name, bytes, 0, bytes.length);
    }
}

```



###### 检验

```java
import load.MyClassLoader;

public class JavaApp {

    public static void main(String [] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        MyClassLoader classLoader = new MyClassLoader();
        Class<?> c1 = classLoader.loadClass("MapImpl1");
        Class<?> c2 = classLoader.loadClass("MapImpl1");
        // 加载过一次之后不会重复加载同一个类
        System.out.println(c1 == c2);
        MyClassLoader classLoader2 = new MyClassLoader();
        Class<?> c3 = classLoader2.loadClass("MapImpl1");
        // 包名相同且类加载器为同一个对象才认为是完全一致的
        System.out.println(c1 == c3);
        // 打印初始化信息
        c1.newInstance();
    }
}

```



#### 双亲委派模式

所谓的双亲委派，就是指调用类加载器的 loadClass 方法时，查找类的规则。

双亲委派模式是指一个类在收到类加载请求后不会尝试自己加载这个类，而是把该类加载请求向上委派给其父类加载器去完成，其父类加载器在接收到该类加载请求后又会将其委派给自己的父类，以此类推，这样所有的类加载请求都被向上委派到启动类加载器中。若父类加载器在接收到类加载请求后发现自己也无法加载该类（通常原因是该类的Class文件在父类的类加载路径中不存在），则父类会将该信息反馈给子类并向下委派子类加载器加载该类，直到该类被成功加载，若找不到该类，则JVM会抛出ClassNotFoud异常。

**这里的双亲，翻译为上级似乎更为合适，因为它们并没有继承关系**



##### 源码分析

查看抽象类 `ClassLoader 的 `loadClass` 方法

```java
    /**
     * Loads the class with the specified <a href="#name">binary name</a>.  The
     * default implementation of this method searches for classes in the
     * following order:
     *
     * <ol>
     *
     *   <li><p> Invoke {@link #findLoadedClass(String)} to check if the class
     *   has already been loaded.  </p></li>
     *
     *   <li><p> Invoke the {@link #loadClass(String) <tt>loadClass</tt>} method
     *   on the parent class loader.  If the parent is <tt>null</tt> the class
     *   loader built-in to the virtual machine is used, instead.  </p></li>
     *
     *   <li><p> Invoke the {@link #findClass(String)} method to find the
     *   class.  </p></li>
     *
     * </ol>
     *
     * <p> If the class was found using the above steps, and the
     * <tt>resolve</tt> flag is true, this method will then invoke the {@link
     * #resolveClass(Class)} method on the resulting <tt>Class</tt> object.
     *
     * <p> Subclasses of <tt>ClassLoader</tt> are encouraged to override {@link
     * #findClass(String)}, rather than this method.  </p>
     *
     * <p> Unless overridden, this method synchronizes on the result of
     * {@link #getClassLoadingLock <tt>getClassLoadingLock</tt>} method
     * during the entire class loading process.
     *
     * @param  name
     *         The <a href="#name">binary name</a> of the class
     *
     * @param  resolve
     *         If <tt>true</tt> then resolve the class
     *
     * @return  The resulting <tt>Class</tt> object
     *
     * @throws  ClassNotFoundException
     *          If the class could not be found
     */
    protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            // 1.检查该类是否已经加载
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    if (parent != null) {
                        // 2.有上级的话，委派上级 loadClass
                        c = parent.loadClass(name, false);
                    } else {
                        // 3.如果没有上级了 (ExtClassLoader), 则委派 BootstrapClassLoader
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // 非空上级类加载器如果没有找到该类会抛出 ClassNotFoundException 异常
                }

                if (c == null) {
                    // 4.每一层都找不到，调用 findClass 方法（每个类加载器自己扩展）来加载
                    long t1 = System.nanoTime();
                    c = findClass(name);

                    // 记录耗时
                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }
```



## 内存模型（JMM）

很多人将【java 内存结构】与【java 内存模型】傻傻分不清，【java 内存模型】是 Java Memory Model（JMM）的意思。

关于它的权威解释，[请参考](https://download.oracle.com/otn-pub/jcp/memory_model-1.0-pfd-spec-oth-JSpec/memory_model-1_0-pfd-spec.pdf) 

简单的说，JMM 定义了一套在多线程读写共享数据时（成员变量、数组）时，对数据的可见性、有序性和原子性的规则保障。



### java 内存模型



#### 原子性



#### 问题分析



#### 解决方法（synchronized）

synchronized（同步关键字）

- 一把锁只能同时被一个线程获取，没有获得锁的线程只能等待
- 同步代码块锁的锁对象为自己指定的锁对象
- 同步方法锁默认锁对象为 this，当前方法的实例对象
- 锁对象是 *.class 以及 synchronized 修饰的是 static 方法的时候，所有对象公用同一把锁
- synchronized修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁

语法

```java
// 同步代码块
synchronized(对象){
    // 要作为原子操作的代码
}

// 同步方法
修饰符 synchronized 返回值 方法名(参数);
public synchronized void method()
public static synchronized void method();

```



用 synchronized 解决并发问题：

```java
public class JavaApp {
    static int i = 0;
    static Object obj = new Object();

    public static void main(String[]args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
           for(int j = 0; j < 5000; j++){
               synchronized (obj){
                   i++;
               }
           }
        });

        Thread t2 = new Thread(() -> {
            for(int j = 0; j < 5000; j++){
                synchronized (obj){
                    i--;
                }
            }
        });

        t1.start();
        t2.start();

        t1.join();
        t2.join();
        System.out.println(i);
    }
}
```



#### 线程同步原理

每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象加锁（重量级锁）之后，该对象头的 Mark Word 中就被设置指向Monitor对象的指针。

Monitor 结构如下

![](D:/documents/notes/pictures/20230315/069.png)



- 刚开始 Monitor 中 Owner 为 null

- 当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor中只能有一个 Owner
- 在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入EntryList，此时线程状态变为BLOCKED状态
- Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争是非公平的（synchronized是非公平锁）
- WaitSet 中的 Thread-0，Thread-1 是之前获得过锁的线程，此时的状态是 WAITING 状态，后面讲wait-notify 时会分析

> 注意
>
> synchronized 必须是进入同一个对象的 monitor 才有上述的效果
>
> 不加 synchronized 的对象不会关联 monitor ，不遵从以上规则



#### 加锁和释放锁的原理

Monitorenter 和Monitorexit 指令，会让对象在执行，使其锁计数器加1或者减1。每一个对象在同一时间只与一个 monitor (锁)相关联，而一个 monitor 在同一时间只能被一个线程获得，一个对象在尝试获得与这个对象相关联的 Monitor 锁的所有权的时候，monitorenter 指令会发生如下3中情况之一：

- monitor 计数器为0，意味着目前还没有被获得，那这个线程就会立刻获得然后把锁计数器+1，一旦+1，别的线程再想获取，就需要等待
- 如果这个 monitor 已经拿到了这个锁的所有权，又重入了这把锁，那锁计数器就会累加，变成2，并且随着重入的次数，会一直累加
- 这把锁已经被别的线程获取了，等待锁释放

Monitorexit 指令：释放对于 monitor 的所有权，释放过程很简单，就是讲 monitor 的计数器减1，如果减完以后，计数器不是0，则代表刚才是重入进来的，当前线程还继续持有这把锁的所有权，如果计数器变成0，则代表当前线程不再拥有该 monitor 的所有权，即释放锁。

**可重入原理：加锁次数计数器**

锁的重入性，即在同一锁程中，线程不需要再次获取同一把锁。

synchronized 先天具有重入性。每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一。





### 可见性

#### 退不出的循环



main 线程对变量 run 的修改对于线程 t 不可见，导致线程 t 无法停止。

```java
public class JavaApp {
    static boolean run = true;

    public static void main(String[]args) throws InterruptedException {
        Thread t = new Thread(() -> {
           while(run){

           }
        });
        t.start();

        Thread.sleep(1000);
        run = false;
    }
}
```



为什么呢？

1.初始状态，t 线程刚开始从主内存读取了 run 的值到工作内存。

![image-20221024225345509](D:/documents/notes/pictures/20230315/070.png)

2.因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存到自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率。

![image-20221024225442836](D:/documents/notes/pictures/20230315/071.png)

3.1秒之后，main 线程修改了 run 的值，并同步至内存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值

![image-20221024225753674](D:/documents/notes/pictures/20230315/072.png)



#### 解决方法（volatile）

volatile（易变关键字）

它可以用来修饰成员变量和静态变量，它可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存。



#### 可见性

前面的例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线程的可见，不能保证原子性，仅用在一个写线程，多个读线程的情况：

上例从字节码理解是这样的：

```java
getstatic	run	// 线程 t 获取 run true
getstatic	run	// 线程 t 获取 run true
getstatic	run	// 线程 t 获取 run true
getstatic	run	// 线程 t 获取 run true
getstatic	run	// 线程 main 修改 run 为 false
getstatic	run	// 线程 t 获取 run false
```

比较一下之前我们将线程安全是举的例子：两个线程一个 i++ 一个 i--

```java
// 假设 i 的初始值为 0 
getstatic	i // 线程 1-获取静态变量 i 的值，线程内 i = 0
getstatic	i // 线程 2-获取静态变量 i 的值，线程内 i = 0
iconst_1	  // 线程 1-准备常量 1
iadd		  // 线程 1-自增 线程内 i = 1;
putstatic	i // 线程 1-将修改后的值存入静态变量 i，静态变量 i = 1
iconst_1	  // 线程 2-准备常量 1
iadd		  // 线程 2-自减 线程内 i = -1;
putstatic	i // 线程 2-将修改后的值存入静态变量 i，静态变量 i = -1
```

#### 

#### 注意

synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是 synchronized 是属于重量级操作，性能相对更低

如果在前面示例的死循环中加入 System.out.println(）会泼现即使不加 vointile 修饰符，线程t也能正确看到对 run 变量的修改了，想一想为什么？

> println() 方法内使用了 synchronized



### 有序性

#### 诡异的结果

```java
public class Actor{
    int num = 0;

    boolean ready = false;

    public int actor1(){
        if (ready) {
            return num + num;
        } else {
            return 1;
        }
    }

    public void actor2(){
        num = 2;
        ready = true;
    }
}
```

actor1()、actor2()分别使用两个线程调用，actor1() 可能会什么值？

情况 1：线程 1 先执行，这时 ready = false，所以进入 else 分支，结果为 1

情况 2：线程 2 先执行 num = 2，但没来得及执行 ready = false，线程 1 执行，还是进入 else 分支，结果为 1 

情况 3：线程 2 执行到 ready = true，线程 1 执行，这回进入 if 分支，结果为 4（这时候 num = 2 已经执行）

情况 4：线程 2 执行到 ready = true，线程 1 执行，这回进入 if 分支，结果为 0（这时候 num = 2 还未执行）

情况 4 叫做指令重排，是 JIT 编译器在运行时的一些优化，这个现象需要通过大量测试才能复现



借助并发压测工具 jcstress

创建一个 jcstress 骨架项目

```xml
<dependency>
    <groupId>org.openjdk.jcstress</groupId>
    <artifactId>jcstress-java-test-archetype</artifactId>
    <version>0.15</version>
</dependency>
```

编写如下测试类

```java
@JCStressTest
@Outcome(id = {"1", "4"}, expect = Expect.ACCEPTABLE, desc = "ok")
@Outcome(id = {"0"}, expect = Expect.ACCEPTABLE_INTERESTING, desc = "!!!!")
@State
public class ConcurrentTest{
    int num = 0;

    boolean ready = false;

    @Actor
    public void actor1(I_Result r){
        if (ready) {
            r.r1 = num + num;
        } else {
            r.r1 = 1;
        }
    }

    @Actor
    public void actor2(){
        num = 2;
        ready = true;
    }
}
```



先执行 `mvn clean install`

打包完成后执行 `E:\Applications\Portable\Oracle\JDK\8u301\bin\java -jar .\target\jcstress.jar`





#### 解决方法（volatile）

volatile 修饰变量后可以实现禁止指令重排序！

java 编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。 为了实现 volatile 的内存语义，JMM 会限制特定类型的编译器和处理器重排序，JMM会针对编译器制定 volatile 重排序规则表：

![](D:/documents/notes/pictures/20230315/073.png)



需要注意的是：volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。

volatile 写

![](D:/documents/notes/pictures/20230315/074.jpeg)

volatile 读

![](D:/documents/notes/pictures/20230315/075.jpeg)



#### 有序性理解

在同一个线程内，JVM 会在不影响正确性的前提下，可以调整语句的执行顺序，思考下面一段代码

```java
static int i;
static int j;

// 在某个线程内执行如下赋值操作
i = ...; // 较为耗时的操作
j = ...;
```

可以看到，至于是先执行 i，还是先执行 j，对最终的结果不会产生影响。所以，上面代码真正执行时，既可以是

```java
i = ...; // 较为耗时的操作
j = ...;
```

也可以是

```java
j = ...;
i = ...; // 较为耗时的操作
```

这种特性称之为【指令重排】，多线程下【指令重排】会影响正确性，例如著名的 double-checked locking 模式实现单例

```java
public final class Singleton {
    private Singleton() {}
    private static Singleton INSTANCE = null;
    public static Singleton getInstance(){
        if(null == INSTANCE){
            synchronized (Singleton.class) {
                if(null == INSTANCE){
                    INSTANCE = new Singleton();
                }
            }
        }
        return INSTANCE;
    }
}

```

以上的实现特点是：

懒惰实例化

首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁

但在多线程环境下，上面的代码是有问题的，`INSTANCE = new Singleton();` 对应的字节码为：

```shell
19: new           #3                  // class app/Singleton
22: dup
23: invokespecial #4                  // Method "<init>":()V
26: putstatic     #2                  // Field INSTANCE:Lapp/Singleton;
```

其中 23 26两个字节码的顺序不是固定的，也许 JVM 会优化为：先将引用地址赋值给 INSTANCE 静态变量后，再执行构造方法，如果两个线程t1，t2 按如下时间顺序执行：

```java
时间1 t1 线程执行到 INSTANCE = new Singleton();
时间2 t1 线程分配空间，为 Singleton 对象生成了引用地址（19）
时间3 t1 线程将引用地址赋值给 INSTANCE，这时，INSTANCE != null（26）
时间4 t2 线程进入 getInstance() 方法，发现 INSTANCE != null（synchronied 块外），直接返回 INSTANCE
时间5 t1 线程执行 Singleton 的构造方法（23）
```

这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的将是一个未初始化完毕的单例

对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排，但要注意在 JDK 5 以上的版本的 volatile 才会真正有效



#### happens-before

happens-before 规定了哪些写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结：

线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见

```java
public class JavaApp {
    static int x;
    static Object m = new Object();
    public static void main(String[]args) {
        new Thread(() ->{
            synchronized (m) {
                x = 10;
            }
        }, "t1").start();
        new Thread(() ->{
            synchronized (m) {
                System.out.println(x);
            }
        }, "t2").start();
    }
}
```

线程对 volatile 变量的写，对接下来其它线程对该变量的读可见

```java
public class JavaApp {
    volatile static int x;
    public static void main(String[]args) {
        new Thread(() ->{
            x = 10;
        }, "t1").start();
        new Thread(() ->{
            System.out.println(x);
        }, "t2").start();
    }
}
```

线程 start 前对变量的写，对该线程 start 后对该变量的读可见

```java
public class JavaApp {
    static int x;
    public static void main(String[]args) {
        x = 10;
        new Thread(() ->{
            System.out.println(x);
        }, "t2").start();
    }
}
```

线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join() 等待它结束）

```java
public class JavaApp {
    static int x;
    public static void main(String[]args) throws InterruptedException {
        Thread t1 = new Thread(() ->{
            x = 10;
        }, "t1");
        t1.start();

        t1.join();
        System.out.println(x);
    }
}
```

线程 t1 打断 t2（interrupt）前对变量的写，对于其它线程得知 t2 被打断后对变量的读可见（通过 t2.interrupted 或 t2.isInterrupted）

```java
public class JavaApp {
    static int x;
    public static void main(String[]args) {
        Thread t2 = new Thread(() ->{
            while (true){
                if(Thread.currentThread().isInterrupted()){
                    System.out.println(x);
                    break;
                }
            }
        }, "t2");
        t2.start();

        new Thread(() ->{
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            x = 10;
            t2.interrupt();
        }, "t1").start();

        while (!t2.isInterrupted()){
            Thread.yield();
        }
        System.out.println(x);
    }
}
```

对变量默认值（0，false，null）的写，对其它线程对该变量的读可见

具有传递性，如果 x hb -> y 并且 y hb -> z 那么有 x hb -> z

> 变量都是指成员变量或静态成员变量
>
> 参考[](https://download.oraele.com/otn-pub/jcp/memory_model-1.0-pfd-spec-oth-JSpec/memory model-1_0-pfd-spec?AuthParam=1562811549_4d4994cbd5b59d964cd2907ea22ca08b) 第 17 页

### CAS 与原子类



#### CAS

CAS 即 Compare And Swap，它体现的一种乐观锁的思想，比如多个线程要对一个共享 `int` 变量执行 `+1` 操作：

```java
while(true){
    int 旧值 = 共享变量; // 比如拿到了当前值 0
    int 结果 = 旧值 + 1; // 在旧值 0 的基础上增加 1，正确结果是 1
    /**
     * 这时候如果别的线程把共享变量修改成 5，本线程的正确结果 1 就作废了，这时候
     * compareAndSwap 返回 false，重新尝试，直到
     * compareAndSwap 返回 true，表示本线程做修改的同时，别的线程没有干扰
     */
    if(compareAndSwap(旧值,结果)){
        // 成功，退出循环
    }
}
```

获取共享变量时，为了保证该变量的可见性，需要使用voIflIe修饰。结合 CAS 和 volatile 可以实现无锁并发，适用于竞争不激烈、多核CPU的场景下。 

- 因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一 
- 但如果竟争激烈，可以想到重试必然频繁发生，反而效率会受影响

CAS底层依赖于一个 Unsafe 类来直接调用操作系统底层的 CAS 指令，下面是直接使用 Unsafe 对象进行线程安全保的一个例子 

```java
public class JavaApp {
    public static void main(String[]args) throws InterruptedException {
        DataContainer dc = new DataContainer();
        int count = 5;
        Thread t1 = new Thread(() -> {
           for(int i = 0; i < count; i++){
               dc.increase();
           }
        });
        t1.start();
        t1.join();
        System.out.println(dc.getData());
    }
}

class DataContainer{
    private volatile int data;
    static final Unsafe unsafe;
    static final long DATA_OFFSET;

    static {
        try{
            Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe");
            theUnsafe.setAccessible(true);
            unsafe = (Unsafe) theUnsafe.get(null);
        } catch (NoSuchFieldException | IllegalAccessException e){
            throw new Error(e);
        }
        try{
            // data 属性在 DataContainer 对象中的偏移量，用于 unsafe 直接访问该属性
            DATA_OFFSET = unsafe.objectFieldOffset(DataContainer.class.getDeclaredField("data"));
        } catch (NoSuchFieldException e) {
            throw new Error(e);
        }
    }

    public void increase(){
        int oldValue;
        while (true){
            oldValue = data;
            if(unsafe.compareAndSwapInt(this, DATA_OFFSET, oldValue, oldValue + 1)){
                return ;
            }
        }
    }

    public void decrease(){
        int oldValue;
        while (true){
            oldValue = data;
            if(unsafe.compareAndSwapInt(this, DATA_OFFSET, oldValue, oldValue - 1)){
                return ;
            }
        }
    }

    public int getData(){
        return data;
    }
}

```



#### 乐观锁与悲观锁

- CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。 
- synchronized 是基于悲观锁的思想：最悲观的估计，得防看其它线程来修改共亨变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会 。





#### 原子操作类

juc（java.util.concurrent）中提供了原子操作类，可以提供线程安全的操作，例如：AtomicInteger、AtomicBoolean 等，它们底层就是采用 CAS 技术 + volatile 来实现的。

可以使用 AtomicInteger 改写之前的例子：

```java
public class JavaApp {
    private static AtomicInteger i = new AtomicInteger(0);
    public static void main(String[]args) throws InterruptedException {
        DataContainer dc = new DataContainer();
        Thread t1 = new Thread(() -> {
           for(int i = 0; i < 5000; i++){
               i.getAndIncrease();
           }
        });
         Thread t2 = new Thread(() -> {
           for(int i = 0; i < 5000; i++){
               i.getAndDecrease();
           }
        });
        t1.start();
        t2.start();
        System.out.println(dc.getData());
    }
}
```





### synchronized 优化

Java HetSpot 虚拟机中每个对象都有对象头（包括 class 指针和 Mark Ward）。 Mark Ward 平时存储这个对 象的哈希码、分代年龄，当加锁时，这些信息就根据倩况被替换为标记位、线程锁记录指针、重量级锁指针、线程 ID 等内容 。

#### 轻量级锁

如果一个对象虽然有多线程访问但多线程访问的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。这就好比： 

学生（线程 A 用课本占座上了半节课，出门了（CPU时间到）回来一看发现课本没变，说明没有竟争，继续上他的课。

如果这期间有其它学生（线程 B）来了，会告知（线移 A）有并发访问，线程 A 随即升级为重量级锁，进入重量级锁的流程。

而重量级锁就不是那么用课本占座那么简单了，可以想象线程 A 走之前把座位用一个铁栅栏围起来，假设有两个方法同步块，利用同一个对象加锁

```java
public class JavaApp {
    private static Object object = new Object();
    public static void main(String[]args) {

    }
    public static void method1(){
        synchronized (object){
            method2();
        }
    }
    public static void method2(){
        synchronized (object){

        }
    }
}
```

每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的 Mark Word

| 线程 1                                           | 对象 Mark Word                | 线程 2                                           |
| ------------------------------------------------ | ----------------------------- | ------------------------------------------------ |
| 访问同步块 A，把 Mark Word 赋值到线程 1 的锁记录 | 01（无锁）                    | -                                                |
| CAS 修改 Mark Word 为线程 1 锁记录地址           | 01（无锁）                    | -                                                |
| 成功（加锁）                                     | 00（轻量锁）线程 1 锁记录地址 | -                                                |
| 执行同步块 A                                     | 00（轻量锁）线程 1 锁记录地址 | -                                                |
| 访问同步块 B，把 Mark Word 复制到线程 1 的锁记录 | 00（轻量锁）线程 1 锁记录地址 | -                                                |
| CAS 修改 Mark Word 为线程 1 锁记录地址           | 00（轻量锁）线程 1 锁记录地址 | -                                                |
| 失败（发现是自己的锁）                           | 00（轻量锁）线程 1 锁记录地址 | -                                                |
| 锁重入                                           | 00（轻量锁）线程 1 锁记录地址 | -                                                |
| 执行同步块 B                                     | 00（轻量锁）线程 1 锁记录地址 | -                                                |
| 同步块 B 执行完毕                                | 00（轻量锁）线程 1 锁记录地址 | -                                                |
| 同步块 A 执行完毕                                | 00（轻量锁）线程 1 锁记录地址 | -                                                |
| 成功（解锁）                                     | 01（无锁）                    | -                                                |
| -                                                | 01（无锁）                    | 访问同步块 A，把 Mark Word 赋值到线程 2 的锁记录 |
| -                                                | 01（无锁）                    | CAS 修改 Mark Word 为线程 2 锁记录地址           |
| -                                                | 00（轻量锁）线程 2 锁记录地址 | 成功（加锁）                                     |
| ...                                              | ...                           | ...                                              |



#### 锁膨胀

如果再尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。

```java
public class JavaApp {
    private static Object object = new Object();
    public static void main(String[]args) {

    }
    public static void method1(){
        synchronized (object){
            method2();
        }
    }
}

```



| 线程 1                                           | 对象 Mark Word                                           | 线程 2                                         |
| ------------------------------------------------ | -------------------------------------------------------- | ---------------------------------------------- |
| 访问同步块 A，把 Mark Word 赋值到线程 1 的锁记录 | 01（无锁）                                               | -                                              |
| CAS 修改 Mark Word 为线程 1 锁记录地址           | 01（无锁）                                               | -                                              |
| 成功（加锁）                                     | 00（轻量锁）线程 1 锁记录地址                            | -                                              |
| 执行同步块                                       | 00（轻量锁）线程 1 锁记录地址                            | -                                              |
| 执行同步块                                       | 00（轻量锁）线程 1 锁记录地址                            | 访问同步块，把 Mark Word 赋值到线程 2 的锁记录 |
| 执行同步块                                       | 00（轻量锁）线程 1 锁记录地址                            | CAS 修改 Mark Word 为线程 2 锁记录地址         |
| 执行同步块                                       | 00（轻量锁）线程 1 锁记录地址                            | 失败（发现别人已经占了锁）                     |
| 执行同步块                                       | 00（轻量锁）线程 1 锁记录地址                            | CAS 修改 Mark Word 为重量级锁                  |
| 执行同步块                                       | 10（重量锁）重量锁指针（用于唤醒那些竞争重量级锁的线程） | 阻塞中                                         |
| 执行完毕                                         | 10（重量锁）重量锁指针                                   | 阻塞中                                         |
| 失败（解锁）                                     | 10（重量锁）重量锁指针                                   | 阻塞中                                         |
| 释放重量锁，唤起阻塞线程竞争                     | 10（重量锁）                                             | 阻塞中                                         |
| -                                                | 10（重量锁）                                             | 竞争重量锁                                     |
| -                                                | 10（重量锁）                                             | 成功（加锁）                                   |
| ...                                              | ...                                                      | ...                                            |



#### 重量锁

重量级锁竟争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。

在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。

- 自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。 
- 好比等红灯时汽车是不是熄火，不熄火相当于自旋（等待时间短了划算），熄火了相当于阻塞（等待时间长了划算）
- Java 7 之后不能控制是否开启自旋功能



自旋重试成功的情况

| 线程 1（CPU 1 上）       | 对象 Mark Word         | 线程 2（CPU 2 上）       |
| ------------------------ | ---------------------- | ------------------------ |
| -                        | 10（重量锁）           | -                        |
| 访问同步块，获取 monitor | 10（重量锁）重量锁指针 | -                        |
| 成功（加锁）             | 10（重量锁）重量锁指针 | -                        |
| 执行同步块               | 10（重量锁）重量锁指针 | -                        |
| 执行同步块               | 10（重量锁）重量锁指针 | 访问同步块，获取 monitor |
| 执行同步块               | 10（重量锁）重量锁指针 | 自旋重试                 |
| 执行完毕                 | 10（重量锁）重量锁指针 | 自旋重试                 |
| 成功（解锁）             | 01（无锁）             | 自旋重试                 |
| -                        | 10（重量锁）重量锁指针 | 成功（加锁）             |
| -                        | 10（重量锁）重量锁指针 | 执行同步块               |
| -                        | ...                    | ...                      |

自旋重试失败的情况

| 线程 1（CPU 1 上）       | 对象 Mark Word         | 线程 2（CPU 2 上）       |
| ------------------------ | ---------------------- | ------------------------ |
| -                        | 10（重量锁）           | -                        |
| 访问同步块，获取 monitor | 10（重量锁）重量锁指针 | -                        |
| 成功（加锁）             | 10（重量锁）重量锁指针 | -                        |
| 执行同步块               | 10（重量锁）重量锁指针 | -                        |
| 执行同步块               | 10（重量锁）重量锁指针 | 访问同步块，获取 monitor |
| 执行同步块               | 10（重量锁）重量锁指针 | 自旋重试                 |
| 执行同步块               | 10（重量锁）重量锁指针 | 自旋重试                 |
| 执行同步块               | 10（重量锁）重量锁指针 | 自旋重试                 |
| 执行同步块               | 10（重量锁）重量锁指针 | 阻塞                     |
| ...                      | ...                    | ...                      |



#### 偏向锁

轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Merk Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。

- 撤销偏向锁需要将持锁线程升级为轻量级锁，这个过程中所有线程需要暂停（STW）
- 访问对象的 hashCode 也会撤销偏向锁
- 如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID
- 撤销偏向和重偏向都是批量进行的，以类为单位
- 如果撤销偏向到达某个阈值，整个类的所有对象都会变为不可偏向的
- 可以主动使用 -XX：-UseBiasedLocking 禁用偏向锁

可以参考这篇 [论文](https://www.oracle.com/technetwork/java/biasedlocking-oopsia2006-wp-149958.pdf)

假设有两个同步块，利用同一个对象加锁

```java
public class JavaApp {
    private static Object object = new Object();
    public static void main(String[]args) {

    }
    public static void method1(){
        synchronized (object){
            method2();
        }
    }
    public static void method2(){
        synchronized (object){

        }
    }
}
```



| 线程 1                                       | 对象 Mark Word                  |
| -------------------------------------------- | ------------------------------- |
| 访问同步块 A，检查 Mark Word 中是否有线程 ID | 101 （无锁可偏向）              |
| 尝试加偏向锁                                 | 101 （无锁可偏向）对象 hashCode |
| 成功                                         | 101 （无锁可偏向）线程 ID       |
| 执行同步块 A                                 | 101 （无锁可偏向）线程 ID       |
| 访问同步块 B，检查 Mark Word 中是否有线程 ID | 101 （无锁可偏向）线程 ID       |
| 是自己的线程 ID，锁是自己的，无需做更多操作  | 101 （无锁可偏向）线程 ID       |
| 执行同步块 B                                 | 101 （无锁可偏向）线程 ID       |
| 执行完毕                                     | 101 （无锁可偏向）对象 hashCode |





#### 其它优化



##### 减少上锁时间

同步代码块尽量短。



##### 减少锁的粒度

将一个锁拆分为多个锁提高并发度，例如：

- ConcurrentHashMap
- LongAdder 分为 base 和 cells 两部分．没有并发争用的时候或者是 cells 数组正在初始化的时候，会使用 CAS 来累加值到 base．有并发争用，会初始化 cells 数组，数组有多少个 cell，就允许有多少线程并行修改，最后将数组中每个 cell 累加，再加上 base 就是最终的值
- LinkedBlockiugQueue 入队和出队使用不同的锁，相对于 LinkedBlockiugArray 只有一个锁效率要高 



##### 锁粗化

多次循环进入同步块不如同步块内多次循环

另外 JVM 可能会做如下优化，把多次 append 的加锁操作粗化为一次（因为都是对同一个对象加锁，没必要重入多次）

```java
new StringBuffer().append("a").append("b").append("c");
```



##### 锁消除

JVM 会进行代码的逃逸分析，例如某个加锁对象是方法内局部变量，不会被其它线程所访问到，这时候就会被即时编译器忽略掉所有同步操作。



##### 读写分离

CopyOnWriteArrayList

CopyOnWriteSet

参考

https://wiki.openjdk.java.net/display/HotSpot/Synchronization

http://luojinping.com/2015/07/09/java锁优化/

https://www.infoq.cn/article/java-se-16-synchronized

https://www.jianshu.com/p/9932047a89be

https://www.cnblogs.com/sheeva/p/6366782.html









